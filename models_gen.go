package tbmodels

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *BalanceMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
			if cap(z.Balance) >= int(zb0002) {
				z.Balance = (z.Balance)[:zb0002]
			} else {
				z.Balance = make([]interface{}, zb0002)
			}
			for za0001 := range z.Balance {
				z.Balance[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Balance", za0001)
					return
				}
			}
		case "o":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
			if cap(z.OpenStake) >= int(zb0003) {
				z.OpenStake = (z.OpenStake)[:zb0003]
			} else {
				z.OpenStake = make([]interface{}, zb0003)
			}
			for za0002 := range z.OpenStake {
				z.OpenStake[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "OpenStake", za0002)
					return
				}
			}
		case "s":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SmartCredit")
				return
			}
			if cap(z.SmartCredit) >= int(zb0004) {
				z.SmartCredit = (z.SmartCredit)[:zb0004]
			} else {
				z.SmartCredit = make([]interface{}, zb0004)
			}
			for za0003 := range z.SmartCredit {
				z.SmartCredit[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "SmartCredit", za0003)
					return
				}
			}
		case "u":
			z.UserID, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "t":
			z.TS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BalanceMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "b"
	err = en.Append(0x85, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Balance)))
	if err != nil {
		err = msgp.WrapError(err, "Balance")
		return
	}
	for za0001 := range z.Balance {
		err = en.WriteIntf(z.Balance[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Balance", za0001)
			return
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OpenStake)))
	if err != nil {
		err = msgp.WrapError(err, "OpenStake")
		return
	}
	for za0002 := range z.OpenStake {
		err = en.WriteIntf(z.OpenStake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "OpenStake", za0002)
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SmartCredit)))
	if err != nil {
		err = msgp.WrapError(err, "SmartCredit")
		return
	}
	for za0003 := range z.SmartCredit {
		err = en.WriteIntf(z.SmartCredit[za0003])
		if err != nil {
			err = msgp.WrapError(err, "SmartCredit", za0003)
			return
		}
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BalanceMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "b"
	o = append(o, 0x85, 0xa1, 0x62)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Balance)))
	for za0001 := range z.Balance {
		o, err = msgp.AppendIntf(o, z.Balance[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Balance", za0001)
			return
		}
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OpenStake)))
	for za0002 := range z.OpenStake {
		o, err = msgp.AppendIntf(o, z.OpenStake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "OpenStake", za0002)
			return
		}
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SmartCredit)))
	for za0003 := range z.SmartCredit {
		o, err = msgp.AppendIntf(o, z.SmartCredit[za0003])
		if err != nil {
			err = msgp.WrapError(err, "SmartCredit", za0003)
			return
		}
	}
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendUint16(o, z.UserID)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendFloat64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BalanceMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
			if cap(z.Balance) >= int(zb0002) {
				z.Balance = (z.Balance)[:zb0002]
			} else {
				z.Balance = make([]interface{}, zb0002)
			}
			for za0001 := range z.Balance {
				z.Balance[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Balance", za0001)
					return
				}
			}
		case "o":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
			if cap(z.OpenStake) >= int(zb0003) {
				z.OpenStake = (z.OpenStake)[:zb0003]
			} else {
				z.OpenStake = make([]interface{}, zb0003)
			}
			for za0002 := range z.OpenStake {
				z.OpenStake[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OpenStake", za0002)
					return
				}
			}
		case "s":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SmartCredit")
				return
			}
			if cap(z.SmartCredit) >= int(zb0004) {
				z.SmartCredit = (z.SmartCredit)[:zb0004]
			} else {
				z.SmartCredit = make([]interface{}, zb0004)
			}
			for za0003 := range z.SmartCredit {
				z.SmartCredit[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SmartCredit", za0003)
					return
				}
			}
		case "u":
			z.UserID, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BalanceMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Balance {
		s += msgp.GuessSize(z.Balance[za0001])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.OpenStake {
		s += msgp.GuessSize(z.OpenStake[za0002])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.SmartCredit {
		s += msgp.GuessSize(z.SmartCredit[za0003])
	}
	s += 2 + msgp.Uint16Size + 2 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetId":
			z.BetId, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BetId")
				return
			}
		case "BetType":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "Bookie":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "CcyRate":
			z.CcyRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "EventId":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "GotPrice":
			z.GotPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "GotPrice")
				return
			}
		case "GotStake":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GotStake")
				return
			}
			if cap(z.GotStake) >= int(zb0002) {
				z.GotStake = (z.GotStake)[:zb0002]
			} else {
				z.GotStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.GotStake {
				z.GotStake[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "GotStake", za0001)
					return
				}
			}
		case "OrderId":
			z.OrderId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ProfitLoss":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0003) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0003]
			} else {
				z.ProfitLoss = make([]interface{}, zb0003)
			}
			for za0002 := range z.ProfitLoss {
				z.ProfitLoss[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0002)
					return
				}
			}
		case "Reconciled":
			z.Reconciled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Reconciled")
				return
			}
		case "Sport":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "Status":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Code":
					z.Status.Code, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "Username":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "WantPrice":
			z.WantPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "WantStake":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0005) {
				z.WantStake = (z.WantStake)[:zb0005]
			} else {
				z.WantStake = make([]interface{}, zb0005)
			}
			for za0003 := range z.WantStake {
				z.WantStake[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0003)
					return
				}
			}
		case "ExchangeRole":
			z.ExchangeRole, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "ExchangeRole")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BetMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 16
	// write "BetId"
	err = en.Append(0xde, 0x0, 0x10, 0xa5, 0x42, 0x65, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BetId)
	if err != nil {
		err = msgp.WrapError(err, "BetId")
		return
	}
	// write "BetType"
	err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "Bookie"
	err = en.Append(0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "CcyRate"
	err = en.Append(0xa7, 0x43, 0x63, 0x79, 0x52, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CcyRate)
	if err != nil {
		err = msgp.WrapError(err, "CcyRate")
		return
	}
	// write "EventId"
	err = en.Append(0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "GotPrice"
	err = en.Append(0xa8, 0x47, 0x6f, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.GotPrice)
	if err != nil {
		err = msgp.WrapError(err, "GotPrice")
		return
	}
	// write "GotStake"
	err = en.Append(0xa8, 0x47, 0x6f, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GotStake)))
	if err != nil {
		err = msgp.WrapError(err, "GotStake")
		return
	}
	for za0001 := range z.GotStake {
		err = en.WriteIntf(z.GotStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "GotStake", za0001)
			return
		}
	}
	// write "OrderId"
	err = en.Append(0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "ProfitLoss"
	err = en.Append(0xaa, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4c, 0x6f, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProfitLoss)))
	if err != nil {
		err = msgp.WrapError(err, "ProfitLoss")
		return
	}
	for za0002 := range z.ProfitLoss {
		err = en.WriteIntf(z.ProfitLoss[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0002)
			return
		}
	}
	// write "Reconciled"
	err = en.Append(0xaa, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Reconciled)
	if err != nil {
		err = msgp.WrapError(err, "Reconciled")
		return
	}
	// write "Sport"
	err = en.Append(0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "Status"
	err = en.Append(0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	// map header, size 1
	// write "Code"
	err = en.Append(0x81, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status.Code)
	if err != nil {
		err = msgp.WrapError(err, "Status", "Code")
		return
	}
	// write "Username"
	err = en.Append(0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "WantPrice"
	err = en.Append(0xa9, 0x57, 0x61, 0x6e, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WantPrice)
	if err != nil {
		err = msgp.WrapError(err, "WantPrice")
		return
	}
	// write "WantStake"
	err = en.Append(0xa9, 0x57, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantStake)))
	if err != nil {
		err = msgp.WrapError(err, "WantStake")
		return
	}
	for za0003 := range z.WantStake {
		err = en.WriteIntf(z.WantStake[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0003)
			return
		}
	}
	// write "ExchangeRole"
	err = en.Append(0xac, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x6f, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.ExchangeRole)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeRole")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BetMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "BetId"
	o = append(o, 0xde, 0x0, 0x10, 0xa5, 0x42, 0x65, 0x74, 0x49, 0x64)
	o = msgp.AppendInt64(o, z.BetId)
	// string "BetType"
	o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.BetType)
	// string "Bookie"
	o = append(o, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	o = msgp.AppendString(o, z.Bookie)
	// string "CcyRate"
	o = append(o, 0xa7, 0x43, 0x63, 0x79, 0x52, 0x61, 0x74, 0x65)
	o = msgp.AppendFloat64(o, z.CcyRate)
	// string "EventId"
	o = append(o, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.EventId)
	// string "GotPrice"
	o = append(o, 0xa8, 0x47, 0x6f, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.GotPrice)
	// string "GotStake"
	o = append(o, 0xa8, 0x47, 0x6f, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GotStake)))
	for za0001 := range z.GotStake {
		o, err = msgp.AppendIntf(o, z.GotStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "GotStake", za0001)
			return
		}
	}
	// string "OrderId"
	o = append(o, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	o = msgp.AppendInt(o, z.OrderId)
	// string "ProfitLoss"
	o = append(o, 0xaa, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4c, 0x6f, 0x73, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProfitLoss)))
	for za0002 := range z.ProfitLoss {
		o, err = msgp.AppendIntf(o, z.ProfitLoss[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0002)
			return
		}
	}
	// string "Reconciled"
	o = append(o, 0xaa, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Reconciled)
	// string "Sport"
	o = append(o, 0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.Sport)
	// string "Status"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	// map header, size 1
	// string "Code"
	o = append(o, 0x81, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Status.Code)
	// string "Username"
	o = append(o, 0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	// string "WantPrice"
	o = append(o, 0xa9, 0x57, 0x61, 0x6e, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.WantPrice)
	// string "WantStake"
	o = append(o, 0xa9, 0x57, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantStake)))
	for za0003 := range z.WantStake {
		o, err = msgp.AppendIntf(o, z.WantStake[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0003)
			return
		}
	}
	// string "ExchangeRole"
	o = append(o, 0xac, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x6f, 0x6c, 0x65)
	o, err = msgp.AppendIntf(o, z.ExchangeRole)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeRole")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetId":
			z.BetId, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetId")
				return
			}
		case "BetType":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "Bookie":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "CcyRate":
			z.CcyRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "EventId":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "GotPrice":
			z.GotPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GotPrice")
				return
			}
		case "GotStake":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GotStake")
				return
			}
			if cap(z.GotStake) >= int(zb0002) {
				z.GotStake = (z.GotStake)[:zb0002]
			} else {
				z.GotStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.GotStake {
				z.GotStake[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GotStake", za0001)
					return
				}
			}
		case "OrderId":
			z.OrderId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ProfitLoss":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0003) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0003]
			} else {
				z.ProfitLoss = make([]interface{}, zb0003)
			}
			for za0002 := range z.ProfitLoss {
				z.ProfitLoss[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0002)
					return
				}
			}
		case "Reconciled":
			z.Reconciled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reconciled")
				return
			}
		case "Sport":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "Status":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Code":
					z.Status.Code, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "Username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "WantPrice":
			z.WantPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "WantStake":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0005) {
				z.WantStake = (z.WantStake)[:zb0005]
			} else {
				z.WantStake = make([]interface{}, zb0005)
			}
			for za0003 := range z.WantStake {
				z.WantStake[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0003)
					return
				}
			}
		case "ExchangeRole":
			z.ExchangeRole, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExchangeRole")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BetMessage) Msgsize() (s int) {
	s = 3 + 6 + msgp.Int64Size + 8 + msgp.StringPrefixSize + len(z.BetType) + 7 + msgp.StringPrefixSize + len(z.Bookie) + 8 + msgp.Float64Size + 8 + msgp.StringPrefixSize + len(z.EventId) + 9 + msgp.Float64Size + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.GotStake {
		s += msgp.GuessSize(z.GotStake[za0001])
	}
	s += 8 + msgp.IntSize + 11 + msgp.ArrayHeaderSize
	for za0002 := range z.ProfitLoss {
		s += msgp.GuessSize(z.ProfitLoss[za0002])
	}
	s += 11 + msgp.BoolSize + 6 + msgp.StringPrefixSize + len(z.Sport) + 7 + 1 + 5 + msgp.StringPrefixSize + len(z.Status.Code) + 9 + msgp.StringPrefixSize + len(z.Username) + 10 + msgp.Float64Size + 10 + msgp.ArrayHeaderSize
	for za0003 := range z.WantStake {
		s += msgp.GuessSize(z.WantStake[za0003])
	}
	s += 13 + msgp.GuessSize(z.ExchangeRole)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetslipClosedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "c":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BetslipClosedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "b"
	err = en.Append(0x82, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BetslipClosedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "b"
	o = append(o, 0x82, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BetslipId)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendString(o, z.CloseReason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetslipClosedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "c":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BetslipClosedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.BetslipId) + 2 + msgp.StringPrefixSize + len(z.CloseReason)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetslipMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetslipId":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "Sport":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "EventId":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "BetType":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "BetTypeTemplate":
			z.BetTypeTemplate, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "BetTypeDescription":
			z.BetTypeDescription, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "ExpiryTs":
			z.ExpiryTs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTs")
				return
			}
		case "IsOpen":
			z.IsOpen, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsOpen")
				return
			}
		case "CloseReason":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "Accounts":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Accounts")
				return
			}
			if cap(z.Accounts) >= int(zb0002) {
				z.Accounts = (z.Accounts)[:zb0002]
			} else {
				z.Accounts = make([]struct {
					Bookie   string `json:"bookie"`
					Username string `json:"username"`
					BetType  string `json:"bet_type"`
				}, zb0002)
			}
			for za0001 := range z.Accounts {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Accounts", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Accounts", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Bookie":
						z.Accounts[za0001].Bookie, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
							return
						}
					case "Username":
						z.Accounts[za0001].Username, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Username")
							return
						}
					case "BetType":
						z.Accounts[za0001].BetType, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "BetType")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001)
							return
						}
					}
				}
			}
		case "MultipleAccounts":
			z.MultipleAccounts, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "MultipleAccounts")
				return
			}
		case "EquivalentBets":
			z.EquivalentBets, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBets")
				return
			}
		case "EquivalentBetsBookies":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBetsBookies")
				return
			}
			if cap(z.EquivalentBetsBookies) >= int(zb0004) {
				z.EquivalentBetsBookies = (z.EquivalentBetsBookies)[:zb0004]
			} else {
				z.EquivalentBetsBookies = make([]string, zb0004)
			}
			for za0002 := range z.EquivalentBetsBookies {
				z.EquivalentBetsBookies[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
					return
				}
			}
		case "WantBookies":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantBookies")
				return
			}
			if cap(z.WantBookies) >= int(zb0005) {
				z.WantBookies = (z.WantBookies)[:zb0005]
			} else {
				z.WantBookies = make([]string, zb0005)
			}
			for za0003 := range z.WantBookies {
				z.WantBookies[za0003], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "WantBookies", za0003)
					return
				}
			}
		case "BookiesWithOffers":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BookiesWithOffers")
				return
			}
			if cap(z.BookiesWithOffers) >= int(zb0006) {
				z.BookiesWithOffers = (z.BookiesWithOffers)[:zb0006]
			} else {
				z.BookiesWithOffers = make([]string, zb0006)
			}
			for za0004 := range z.BookiesWithOffers {
				z.BookiesWithOffers[za0004], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BookiesWithOffers", za0004)
					return
				}
			}
		case "CustomerUsername":
			z.CustomerUsername, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CustomerUsername")
				return
			}
		case "CustomerCcy":
			z.CustomerCcy, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CustomerCcy")
				return
			}
		case "BetslipType":
			z.BetslipType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipType")
				return
			}
		case "Ts":
			z.Ts, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		case "InvalidAccounts":
			z.InvalidAccounts, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "InvalidAccounts")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BetslipMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 20
	// write "BetslipId"
	err = en.Append(0xde, 0x0, 0x14, 0xa9, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "Sport"
	err = en.Append(0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "EventId"
	err = en.Append(0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "BetType"
	err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "BetTypeTemplate"
	err = en.Append(0xaf, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeTemplate)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeTemplate")
		return
	}
	// write "BetTypeDescription"
	err = en.Append(0xb2, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeDescription)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeDescription")
		return
	}
	// write "ExpiryTs"
	err = en.Append(0xa8, 0x45, 0x78, 0x70, 0x69, 0x72, 0x79, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.ExpiryTs)
	if err != nil {
		err = msgp.WrapError(err, "ExpiryTs")
		return
	}
	// write "IsOpen"
	err = en.Append(0xa6, 0x49, 0x73, 0x4f, 0x70, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsOpen)
	if err != nil {
		err = msgp.WrapError(err, "IsOpen")
		return
	}
	// write "CloseReason"
	err = en.Append(0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "Accounts"
	err = en.Append(0xa8, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Accounts)))
	if err != nil {
		err = msgp.WrapError(err, "Accounts")
		return
	}
	for za0001 := range z.Accounts {
		// map header, size 3
		// write "Bookie"
		err = en.Append(0x83, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].Bookie)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
			return
		}
		// write "Username"
		err = en.Append(0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].Username)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "Username")
			return
		}
		// write "BetType"
		err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].BetType)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "BetType")
			return
		}
	}
	// write "MultipleAccounts"
	err = en.Append(0xb0, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.MultipleAccounts)
	if err != nil {
		err = msgp.WrapError(err, "MultipleAccounts")
		return
	}
	// write "EquivalentBets"
	err = en.Append(0xae, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x42, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.EquivalentBets)
	if err != nil {
		err = msgp.WrapError(err, "EquivalentBets")
		return
	}
	// write "EquivalentBetsBookies"
	err = en.Append(0xb5, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x42, 0x65, 0x74, 0x73, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.EquivalentBetsBookies)))
	if err != nil {
		err = msgp.WrapError(err, "EquivalentBetsBookies")
		return
	}
	for za0002 := range z.EquivalentBetsBookies {
		err = en.WriteString(z.EquivalentBetsBookies[za0002])
		if err != nil {
			err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
			return
		}
	}
	// write "WantBookies"
	err = en.Append(0xab, 0x57, 0x61, 0x6e, 0x74, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantBookies)))
	if err != nil {
		err = msgp.WrapError(err, "WantBookies")
		return
	}
	for za0003 := range z.WantBookies {
		err = en.WriteString(z.WantBookies[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantBookies", za0003)
			return
		}
	}
	// write "BookiesWithOffers"
	err = en.Append(0xb1, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73, 0x57, 0x69, 0x74, 0x68, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BookiesWithOffers)))
	if err != nil {
		err = msgp.WrapError(err, "BookiesWithOffers")
		return
	}
	for za0004 := range z.BookiesWithOffers {
		err = en.WriteString(z.BookiesWithOffers[za0004])
		if err != nil {
			err = msgp.WrapError(err, "BookiesWithOffers", za0004)
			return
		}
	}
	// write "CustomerUsername"
	err = en.Append(0xb0, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.CustomerUsername)
	if err != nil {
		err = msgp.WrapError(err, "CustomerUsername")
		return
	}
	// write "CustomerCcy"
	err = en.Append(0xab, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x43, 0x63, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.CustomerCcy)
	if err != nil {
		err = msgp.WrapError(err, "CustomerCcy")
		return
	}
	// write "BetslipType"
	err = en.Append(0xab, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipType)
	if err != nil {
		err = msgp.WrapError(err, "BetslipType")
		return
	}
	// write "Ts"
	err = en.Append(0xa2, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Ts)
	if err != nil {
		err = msgp.WrapError(err, "Ts")
		return
	}
	// write "InvalidAccounts"
	err = en.Append(0xaf, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.InvalidAccounts)
	if err != nil {
		err = msgp.WrapError(err, "InvalidAccounts")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BetslipMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 20
	// string "BetslipId"
	o = append(o, 0xde, 0x0, 0x14, 0xa9, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x49, 0x64)
	o = msgp.AppendString(o, z.BetslipId)
	// string "Sport"
	o = append(o, 0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.Sport)
	// string "EventId"
	o = append(o, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.EventId)
	// string "BetType"
	o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.BetType)
	// string "BetTypeTemplate"
	o = append(o, 0xaf, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.BetTypeTemplate)
	// string "BetTypeDescription"
	o = append(o, 0xb2, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.BetTypeDescription)
	// string "ExpiryTs"
	o = append(o, 0xa8, 0x45, 0x78, 0x70, 0x69, 0x72, 0x79, 0x54, 0x73)
	o = msgp.AppendFloat64(o, z.ExpiryTs)
	// string "IsOpen"
	o = append(o, 0xa6, 0x49, 0x73, 0x4f, 0x70, 0x65, 0x6e)
	o = msgp.AppendBool(o, z.IsOpen)
	// string "CloseReason"
	o = append(o, 0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.CloseReason)
	// string "Accounts"
	o = append(o, 0xa8, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Accounts)))
	for za0001 := range z.Accounts {
		// map header, size 3
		// string "Bookie"
		o = append(o, 0x83, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
		o = msgp.AppendString(o, z.Accounts[za0001].Bookie)
		// string "Username"
		o = append(o, 0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Accounts[za0001].Username)
		// string "BetType"
		o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Accounts[za0001].BetType)
	}
	// string "MultipleAccounts"
	o = append(o, 0xb0, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	o = msgp.AppendBool(o, z.MultipleAccounts)
	// string "EquivalentBets"
	o = append(o, 0xae, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x42, 0x65, 0x74, 0x73)
	o = msgp.AppendBool(o, z.EquivalentBets)
	// string "EquivalentBetsBookies"
	o = append(o, 0xb5, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x42, 0x65, 0x74, 0x73, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.EquivalentBetsBookies)))
	for za0002 := range z.EquivalentBetsBookies {
		o = msgp.AppendString(o, z.EquivalentBetsBookies[za0002])
	}
	// string "WantBookies"
	o = append(o, 0xab, 0x57, 0x61, 0x6e, 0x74, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantBookies)))
	for za0003 := range z.WantBookies {
		o = msgp.AppendString(o, z.WantBookies[za0003])
	}
	// string "BookiesWithOffers"
	o = append(o, 0xb1, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x73, 0x57, 0x69, 0x74, 0x68, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BookiesWithOffers)))
	for za0004 := range z.BookiesWithOffers {
		o = msgp.AppendString(o, z.BookiesWithOffers[za0004])
	}
	// string "CustomerUsername"
	o = append(o, 0xb0, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.CustomerUsername)
	// string "CustomerCcy"
	o = append(o, 0xab, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x43, 0x63, 0x79)
	o = msgp.AppendString(o, z.CustomerCcy)
	// string "BetslipType"
	o = append(o, 0xab, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.BetslipType)
	// string "Ts"
	o = append(o, 0xa2, 0x54, 0x73)
	o = msgp.AppendFloat64(o, z.Ts)
	// string "InvalidAccounts"
	o = append(o, 0xaf, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	o, err = msgp.AppendIntf(o, z.InvalidAccounts)
	if err != nil {
		err = msgp.WrapError(err, "InvalidAccounts")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetslipMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetslipId":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "Sport":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "EventId":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "BetType":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "BetTypeTemplate":
			z.BetTypeTemplate, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "BetTypeDescription":
			z.BetTypeDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "ExpiryTs":
			z.ExpiryTs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTs")
				return
			}
		case "IsOpen":
			z.IsOpen, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsOpen")
				return
			}
		case "CloseReason":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "Accounts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Accounts")
				return
			}
			if cap(z.Accounts) >= int(zb0002) {
				z.Accounts = (z.Accounts)[:zb0002]
			} else {
				z.Accounts = make([]struct {
					Bookie   string `json:"bookie"`
					Username string `json:"username"`
					BetType  string `json:"bet_type"`
				}, zb0002)
			}
			for za0001 := range z.Accounts {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Bookie":
						z.Accounts[za0001].Bookie, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
							return
						}
					case "Username":
						z.Accounts[za0001].Username, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Username")
							return
						}
					case "BetType":
						z.Accounts[za0001].BetType, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "BetType")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001)
							return
						}
					}
				}
			}
		case "MultipleAccounts":
			z.MultipleAccounts, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MultipleAccounts")
				return
			}
		case "EquivalentBets":
			z.EquivalentBets, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBets")
				return
			}
		case "EquivalentBetsBookies":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBetsBookies")
				return
			}
			if cap(z.EquivalentBetsBookies) >= int(zb0004) {
				z.EquivalentBetsBookies = (z.EquivalentBetsBookies)[:zb0004]
			} else {
				z.EquivalentBetsBookies = make([]string, zb0004)
			}
			for za0002 := range z.EquivalentBetsBookies {
				z.EquivalentBetsBookies[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
					return
				}
			}
		case "WantBookies":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantBookies")
				return
			}
			if cap(z.WantBookies) >= int(zb0005) {
				z.WantBookies = (z.WantBookies)[:zb0005]
			} else {
				z.WantBookies = make([]string, zb0005)
			}
			for za0003 := range z.WantBookies {
				z.WantBookies[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantBookies", za0003)
					return
				}
			}
		case "BookiesWithOffers":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BookiesWithOffers")
				return
			}
			if cap(z.BookiesWithOffers) >= int(zb0006) {
				z.BookiesWithOffers = (z.BookiesWithOffers)[:zb0006]
			} else {
				z.BookiesWithOffers = make([]string, zb0006)
			}
			for za0004 := range z.BookiesWithOffers {
				z.BookiesWithOffers[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BookiesWithOffers", za0004)
					return
				}
			}
		case "CustomerUsername":
			z.CustomerUsername, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CustomerUsername")
				return
			}
		case "CustomerCcy":
			z.CustomerCcy, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CustomerCcy")
				return
			}
		case "BetslipType":
			z.BetslipType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipType")
				return
			}
		case "Ts":
			z.Ts, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		case "InvalidAccounts":
			z.InvalidAccounts, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvalidAccounts")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BetslipMessage) Msgsize() (s int) {
	s = 3 + 10 + msgp.StringPrefixSize + len(z.BetslipId) + 6 + msgp.StringPrefixSize + len(z.Sport) + 8 + msgp.StringPrefixSize + len(z.EventId) + 8 + msgp.StringPrefixSize + len(z.BetType) + 16 + msgp.StringPrefixSize + len(z.BetTypeTemplate) + 19 + msgp.StringPrefixSize + len(z.BetTypeDescription) + 9 + msgp.Float64Size + 7 + msgp.BoolSize + 12 + msgp.StringPrefixSize + len(z.CloseReason) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Accounts {
		s += 1 + 7 + msgp.StringPrefixSize + len(z.Accounts[za0001].Bookie) + 9 + msgp.StringPrefixSize + len(z.Accounts[za0001].Username) + 8 + msgp.StringPrefixSize + len(z.Accounts[za0001].BetType)
	}
	s += 17 + msgp.BoolSize + 15 + msgp.BoolSize + 22 + msgp.ArrayHeaderSize
	for za0002 := range z.EquivalentBetsBookies {
		s += msgp.StringPrefixSize + len(z.EquivalentBetsBookies[za0002])
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0003 := range z.WantBookies {
		s += msgp.StringPrefixSize + len(z.WantBookies[za0003])
	}
	s += 18 + msgp.ArrayHeaderSize
	for za0004 := range z.BookiesWithOffers {
		s += msgp.StringPrefixSize + len(z.BookiesWithOffers[za0004])
	}
	s += 17 + msgp.StringPrefixSize + len(z.CustomerUsername) + 12 + msgp.StringPrefixSize + len(z.CustomerCcy) + 12 + msgp.StringPrefixSize + len(z.BetslipType) + 3 + msgp.Float64Size + 16 + msgp.GuessSize(z.InvalidAccounts)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DisconnectedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "e":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DisconnectedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "u"
	err = en.Append(0x82, 0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Error)
	if err != nil {
		err = msgp.WrapError(err, "Error")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DisconnectedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "u"
	o = append(o, 0x82, 0xa1, 0x75)
	o = msgp.AppendString(o, z.Username)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendString(o, z.Error)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DisconnectedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "e":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DisconnectedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Effective) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Price":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Min":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
			if cap(z.Min) >= int(zb0002) {
				z.Min = (z.Min)[:zb0002]
			} else {
				z.Min = make([]interface{}, zb0002)
			}
			for za0001 := range z.Min {
				z.Min[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Min", za0001)
					return
				}
			}
		case "Max":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			if cap(z.Max) >= int(zb0003) {
				z.Max = (z.Max)[:zb0003]
			} else {
				z.Max = make([]interface{}, zb0003)
			}
			for za0002 := range z.Max {
				z.Max[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Max", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Effective) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Price"
	err = en.Append(0x83, 0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "Min"
	err = en.Append(0xa3, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Min)))
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	for za0001 := range z.Min {
		err = en.WriteIntf(z.Min[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Min", za0001)
			return
		}
	}
	// write "Max"
	err = en.Append(0xa3, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Max)))
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	for za0002 := range z.Max {
		err = en.WriteIntf(z.Max[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Max", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Effective) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Price"
	o = append(o, 0x83, 0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.Price)
	// string "Min"
	o = append(o, 0xa3, 0x4d, 0x69, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Min)))
	for za0001 := range z.Min {
		o, err = msgp.AppendIntf(o, z.Min[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Min", za0001)
			return
		}
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Max)))
	for za0002 := range z.Max {
		o, err = msgp.AppendIntf(o, z.Max[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Max", za0002)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Effective) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Price":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Min":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
			if cap(z.Min) >= int(zb0002) {
				z.Min = (z.Min)[:zb0002]
			} else {
				z.Min = make([]interface{}, zb0002)
			}
			for za0001 := range z.Min {
				z.Min[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Min", za0001)
					return
				}
			}
		case "Max":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			if cap(z.Max) >= int(zb0003) {
				z.Max = (z.Max)[:zb0003]
			} else {
				z.Max = make([]interface{}, zb0003)
			}
			for za0002 := range z.Max {
				z.Max[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Max", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Effective) Msgsize() (s int) {
	s = 1 + 6 + msgp.Float64Size + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.Min {
		s += msgp.GuessSize(z.Min[za0001])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0002 := range z.Max {
		s += msgp.GuessSize(z.Max[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EventInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "EventId":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "HomeId":
			z.HomeId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HomeId")
				return
			}
		case "HomeTeam":
			z.HomeTeam, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HomeTeam")
				return
			}
		case "AwayId":
			z.AwayId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AwayId")
				return
			}
		case "AwayTeam":
			z.AwayTeam, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AwayTeam")
				return
			}
		case "CompetitionId":
			z.CompetitionId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionId")
				return
			}
		case "CompetitionName":
			z.CompetitionName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionName")
				return
			}
		case "CompetitionCountry":
			z.CompetitionCountry, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionCountry")
				return
			}
		case "StartTime":
			z.StartTime, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "Date":
			z.Date, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Result":
			err = z.Result.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *EventInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "EventId"
	err = en.Append(0x8b, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "HomeId"
	err = en.Append(0xa6, 0x48, 0x6f, 0x6d, 0x65, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HomeId)
	if err != nil {
		err = msgp.WrapError(err, "HomeId")
		return
	}
	// write "HomeTeam"
	err = en.Append(0xa8, 0x48, 0x6f, 0x6d, 0x65, 0x54, 0x65, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.HomeTeam)
	if err != nil {
		err = msgp.WrapError(err, "HomeTeam")
		return
	}
	// write "AwayId"
	err = en.Append(0xa6, 0x41, 0x77, 0x61, 0x79, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AwayId)
	if err != nil {
		err = msgp.WrapError(err, "AwayId")
		return
	}
	// write "AwayTeam"
	err = en.Append(0xa8, 0x41, 0x77, 0x61, 0x79, 0x54, 0x65, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.AwayTeam)
	if err != nil {
		err = msgp.WrapError(err, "AwayTeam")
		return
	}
	// write "CompetitionId"
	err = en.Append(0xad, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CompetitionId)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionId")
		return
	}
	// write "CompetitionName"
	err = en.Append(0xaf, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.CompetitionName)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionName")
		return
	}
	// write "CompetitionCountry"
	err = en.Append(0xb2, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.CompetitionCountry)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionCountry")
		return
	}
	// write "StartTime"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "Date"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Date)
	if err != nil {
		err = msgp.WrapError(err, "Date")
		return
	}
	// write "Result"
	err = en.Append(0xa6, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	if err != nil {
		return
	}
	err = z.Result.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Result")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "EventId"
	o = append(o, 0x8b, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.EventId)
	// string "HomeId"
	o = append(o, 0xa6, 0x48, 0x6f, 0x6d, 0x65, 0x49, 0x64)
	o = msgp.AppendInt(o, z.HomeId)
	// string "HomeTeam"
	o = append(o, 0xa8, 0x48, 0x6f, 0x6d, 0x65, 0x54, 0x65, 0x61, 0x6d)
	o = msgp.AppendString(o, z.HomeTeam)
	// string "AwayId"
	o = append(o, 0xa6, 0x41, 0x77, 0x61, 0x79, 0x49, 0x64)
	o = msgp.AppendInt(o, z.AwayId)
	// string "AwayTeam"
	o = append(o, 0xa8, 0x41, 0x77, 0x61, 0x79, 0x54, 0x65, 0x61, 0x6d)
	o = msgp.AppendString(o, z.AwayTeam)
	// string "CompetitionId"
	o = append(o, 0xad, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64)
	o = msgp.AppendInt(o, z.CompetitionId)
	// string "CompetitionName"
	o = append(o, 0xaf, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.CompetitionName)
	// string "CompetitionCountry"
	o = append(o, 0xb2, 0x43, 0x6f, 0x6d, 0x70, 0x65, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79)
	o = msgp.AppendString(o, z.CompetitionCountry)
	// string "StartTime"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendString(o, z.StartTime)
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.Date)
	// string "Result"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	o, err = z.Result.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Result")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "EventId":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "HomeId":
			z.HomeId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HomeId")
				return
			}
		case "HomeTeam":
			z.HomeTeam, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HomeTeam")
				return
			}
		case "AwayId":
			z.AwayId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AwayId")
				return
			}
		case "AwayTeam":
			z.AwayTeam, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AwayTeam")
				return
			}
		case "CompetitionId":
			z.CompetitionId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionId")
				return
			}
		case "CompetitionName":
			z.CompetitionName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionName")
				return
			}
		case "CompetitionCountry":
			z.CompetitionCountry, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionCountry")
				return
			}
		case "StartTime":
			z.StartTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "Date":
			z.Date, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Result":
			bts, err = z.Result.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventInfo) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.EventId) + 7 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.HomeTeam) + 7 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.AwayTeam) + 14 + msgp.IntSize + 16 + msgp.StringPrefixSize + len(z.CompetitionName) + 19 + msgp.StringPrefixSize + len(z.CompetitionCountry) + 10 + msgp.StringPrefixSize + len(z.StartTime) + 5 + msgp.StringPrefixSize + len(z.Date) + 7 + z.Result.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InfoMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "q":
			z.QueueSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QueueSize")
				return
			}
		case "m":
			z.QueueSizeMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QueueSizeMax")
				return
			}
		case "r":
			z.RegisteredEvents, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RegisteredEvents")
				return
			}
		case "x":
			z.MaxQueueSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxQueueSize")
				return
			}
		case "t":
			z.TS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *InfoMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "q"
	err = en.Append(0x85, 0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QueueSize)
	if err != nil {
		err = msgp.WrapError(err, "QueueSize")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QueueSizeMax)
	if err != nil {
		err = msgp.WrapError(err, "QueueSizeMax")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RegisteredEvents)
	if err != nil {
		err = msgp.WrapError(err, "RegisteredEvents")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxQueueSize)
	if err != nil {
		err = msgp.WrapError(err, "MaxQueueSize")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InfoMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "q"
	o = append(o, 0x85, 0xa1, 0x71)
	o = msgp.AppendInt(o, z.QueueSize)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendInt(o, z.QueueSizeMax)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendInt(o, z.RegisteredEvents)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendInt(o, z.MaxQueueSize)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendFloat64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InfoMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "q":
			z.QueueSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueueSize")
				return
			}
		case "m":
			z.QueueSizeMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueueSizeMax")
				return
			}
		case "r":
			z.RegisteredEvents, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RegisteredEvents")
				return
			}
		case "x":
			z.MaxQueueSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxQueueSize")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InfoMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Offer) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "A":
			z.A, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "A")
				return
			}
		case "B":
			z.B, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "B")
				return
			}
		case "C":
			z.C, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "C")
				return
			}
		case "I":
			z.I, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "I")
				return
			}
		case "N":
			z.N, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Offer) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "A"
	err = en.Append(0x85, 0xa1, 0x41)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.A)
	if err != nil {
		err = msgp.WrapError(err, "A")
		return
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.B)
	if err != nil {
		err = msgp.WrapError(err, "B")
		return
	}
	// write "C"
	err = en.Append(0xa1, 0x43)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.C)
	if err != nil {
		err = msgp.WrapError(err, "C")
		return
	}
	// write "I"
	err = en.Append(0xa1, 0x49)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.I)
	if err != nil {
		err = msgp.WrapError(err, "I")
		return
	}
	// write "N"
	err = en.Append(0xa1, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteString(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Offer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "A"
	o = append(o, 0x85, 0xa1, 0x41)
	o = msgp.AppendFloat64(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendFloat64(o, z.B)
	// string "C"
	o = append(o, 0xa1, 0x43)
	o = msgp.AppendFloat64(o, z.C)
	// string "I"
	o = append(o, 0xa1, 0x49)
	o = msgp.AppendInt64(o, z.I)
	// string "N"
	o = append(o, 0xa1, 0x4e)
	o = msgp.AppendString(o, z.N)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Offer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "A":
			z.A, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "A")
				return
			}
		case "B":
			z.B, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "B")
				return
			}
		case "C":
			z.C, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "C")
				return
			}
		case "I":
			z.I, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "I")
				return
			}
		case "N":
			z.N, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Offer) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int64Size + 2 + msgp.StringPrefixSize + len(z.N)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OffersMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "e":
			z.EventID, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "s":
			z.Starts, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "Starts")
				return
			}
		case "p":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "w":
			z.WsReceive, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "o":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OfferList")
				return
			}
			if cap(z.OfferList) >= int(zb0002) {
				z.OfferList = (z.OfferList)[:zb0002]
			} else {
				z.OfferList = make([]Offer, zb0002)
			}
			for za0001 := range z.OfferList {
				err = z.OfferList[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OfferList", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OffersMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "e"
	err = en.Append(0x85, 0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EventID)
	if err != nil {
		err = msgp.WrapError(err, "EventID")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Starts)
	if err != nil {
		err = msgp.WrapError(err, "Starts")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteTime(z.WsReceive)
	if err != nil {
		err = msgp.WrapError(err, "WsReceive")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OfferList)))
	if err != nil {
		err = msgp.WrapError(err, "OfferList")
		return
	}
	for za0001 := range z.OfferList {
		err = z.OfferList[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OfferList", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OffersMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "e"
	o = append(o, 0x85, 0xa1, 0x65)
	o = msgp.AppendInt64(o, z.EventID)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendTime(o, z.Starts)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendString(o, z.Sport)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendTime(o, z.WsReceive)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OfferList)))
	for za0001 := range z.OfferList {
		o, err = z.OfferList[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "OfferList", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OffersMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "e":
			z.EventID, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "s":
			z.Starts, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Starts")
				return
			}
		case "p":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "w":
			z.WsReceive, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "o":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfferList")
				return
			}
			if cap(z.OfferList) >= int(zb0002) {
				z.OfferList = (z.OfferList)[:zb0002]
			} else {
				z.OfferList = make([]Offer, zb0002)
			}
			for za0001 := range z.OfferList {
				bts, err = z.OfferList[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfferList", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OffersMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size + 2 + msgp.TimeSize + 2 + msgp.StringPrefixSize + len(z.Sport) + 2 + msgp.TimeSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.OfferList {
		s += z.OfferList[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OrderDataMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderId":
			z.OrderId, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "OrderType":
			z.OrderType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderType")
				return
			}
		case "BetType":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "BetTypeTemplate":
			z.BetTypeTemplate, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "BetTypeDescription":
			z.BetTypeDescription, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "Sport":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "Placer":
			z.Placer, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Placer")
				return
			}
		case "WantPrice":
			z.WantPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "WantStake":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0002) {
				z.WantStake = (z.WantStake)[:zb0002]
			} else {
				z.WantStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.WantStake {
				z.WantStake[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0001)
					return
				}
			}
		case "CcyRate":
			z.CcyRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "PlacementTime":
			z.PlacementTime, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PlacementTime")
				return
			}
		case "ExpiryTime":
			z.ExpiryTime, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTime")
				return
			}
		case "Closed":
			z.Closed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "CloseReason":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "EventInfo":
			err = z.EventInfo.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "EventInfo")
				return
			}
		case "UserData":
			z.UserData, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UserData")
				return
			}
		case "Status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "KeepOpenIr":
			z.KeepOpenIr, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "KeepOpenIr")
				return
			}
		case "ExchangeMode":
			z.ExchangeMode, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ExchangeMode")
				return
			}
		case "Price":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Stake":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Stake")
				return
			}
			if cap(z.Stake) >= int(zb0003) {
				z.Stake = (z.Stake)[:zb0003]
			} else {
				z.Stake = make([]interface{}, zb0003)
			}
			for za0002 := range z.Stake {
				z.Stake[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Stake", za0002)
					return
				}
			}
		case "ProfitLoss":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0004) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0004]
			} else {
				z.ProfitLoss = make([]interface{}, zb0004)
			}
			for za0003 := range z.ProfitLoss {
				z.ProfitLoss[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0003)
					return
				}
			}
		case "Bets":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Bets")
				return
			}
			if cap(z.Bets) >= int(zb0005) {
				z.Bets = (z.Bets)[:zb0005]
			} else {
				z.Bets = make([]BetMessage, zb0005)
			}
			for za0004 := range z.Bets {
				err = z.Bets[za0004].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Bets", za0004)
					return
				}
			}
		case "BetBarValues":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "BetBarValues")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "BetBarValues")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Success":
					var zb0007 uint32
					zb0007, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Success")
						return
					}
					if cap(z.BetBarValues.Success) >= int(zb0007) {
						z.BetBarValues.Success = (z.BetBarValues.Success)[:zb0007]
					} else {
						z.BetBarValues.Success = make([]interface{}, zb0007)
					}
					for za0005 := range z.BetBarValues.Success {
						z.BetBarValues.Success[za0005], err = dc.ReadIntf()
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Success", za0005)
							return
						}
					}
				case "Inprogress":
					var zb0008 uint32
					zb0008, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Inprogress")
						return
					}
					if cap(z.BetBarValues.Inprogress) >= int(zb0008) {
						z.BetBarValues.Inprogress = (z.BetBarValues.Inprogress)[:zb0008]
					} else {
						z.BetBarValues.Inprogress = make([]interface{}, zb0008)
					}
					for za0006 := range z.BetBarValues.Inprogress {
						z.BetBarValues.Inprogress[za0006], err = dc.ReadIntf()
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Inprogress", za0006)
							return
						}
					}
				case "Danger":
					var zb0009 uint32
					zb0009, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Danger")
						return
					}
					if cap(z.BetBarValues.Danger) >= int(zb0009) {
						z.BetBarValues.Danger = (z.BetBarValues.Danger)[:zb0009]
					} else {
						z.BetBarValues.Danger = make([]interface{}, zb0009)
					}
					for za0007 := range z.BetBarValues.Danger {
						z.BetBarValues.Danger[za0007], err = dc.ReadIntf()
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Danger", za0007)
							return
						}
					}
				case "Unplaced":
					var zb0010 uint32
					zb0010, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Unplaced")
						return
					}
					if cap(z.BetBarValues.Unplaced) >= int(zb0010) {
						z.BetBarValues.Unplaced = (z.BetBarValues.Unplaced)[:zb0010]
					} else {
						z.BetBarValues.Unplaced = make([]interface{}, zb0010)
					}
					for za0008 := range z.BetBarValues.Unplaced {
						z.BetBarValues.Unplaced[za0008], err = dc.ReadIntf()
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Unplaced", za0008)
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues")
						return
					}
				}
			}
		case "Ts":
			z.Ts, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		case "BetBookieList":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BetBookieList")
				return
			}
			if cap(z.BetBookieList) >= int(zb0011) {
				z.BetBookieList = (z.BetBookieList)[:zb0011]
			} else {
				z.BetBookieList = make([]string, zb0011)
			}
			for za0009 := range z.BetBookieList {
				z.BetBookieList[za0009], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BetBookieList", za0009)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OrderDataMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 26
	// write "OrderId"
	err = en.Append(0xde, 0x0, 0x1a, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "OrderType"
	err = en.Append(0xa9, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderType)
	if err != nil {
		err = msgp.WrapError(err, "OrderType")
		return
	}
	// write "BetType"
	err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "BetTypeTemplate"
	err = en.Append(0xaf, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeTemplate)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeTemplate")
		return
	}
	// write "BetTypeDescription"
	err = en.Append(0xb2, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeDescription)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeDescription")
		return
	}
	// write "Sport"
	err = en.Append(0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "Placer"
	err = en.Append(0xa6, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Placer)
	if err != nil {
		err = msgp.WrapError(err, "Placer")
		return
	}
	// write "WantPrice"
	err = en.Append(0xa9, 0x57, 0x61, 0x6e, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WantPrice)
	if err != nil {
		err = msgp.WrapError(err, "WantPrice")
		return
	}
	// write "WantStake"
	err = en.Append(0xa9, 0x57, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantStake)))
	if err != nil {
		err = msgp.WrapError(err, "WantStake")
		return
	}
	for za0001 := range z.WantStake {
		err = en.WriteIntf(z.WantStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0001)
			return
		}
	}
	// write "CcyRate"
	err = en.Append(0xa7, 0x43, 0x63, 0x79, 0x52, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CcyRate)
	if err != nil {
		err = msgp.WrapError(err, "CcyRate")
		return
	}
	// write "PlacementTime"
	err = en.Append(0xad, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.PlacementTime)
	if err != nil {
		err = msgp.WrapError(err, "PlacementTime")
		return
	}
	// write "ExpiryTime"
	err = en.Append(0xaa, 0x45, 0x78, 0x70, 0x69, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ExpiryTime)
	if err != nil {
		err = msgp.WrapError(err, "ExpiryTime")
		return
	}
	// write "Closed"
	err = en.Append(0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Closed)
	if err != nil {
		err = msgp.WrapError(err, "Closed")
		return
	}
	// write "CloseReason"
	err = en.Append(0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "EventInfo"
	err = en.Append(0xa9, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = z.EventInfo.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "EventInfo")
		return
	}
	// write "UserData"
	err = en.Append(0xa8, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(z.UserData)
	if err != nil {
		err = msgp.WrapError(err, "UserData")
		return
	}
	// write "Status"
	err = en.Append(0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status)
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	// write "KeepOpenIr"
	err = en.Append(0xaa, 0x4b, 0x65, 0x65, 0x70, 0x4f, 0x70, 0x65, 0x6e, 0x49, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.KeepOpenIr)
	if err != nil {
		err = msgp.WrapError(err, "KeepOpenIr")
		return
	}
	// write "ExchangeMode"
	err = en.Append(0xac, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x4d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ExchangeMode)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeMode")
		return
	}
	// write "Price"
	err = en.Append(0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "Stake"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Stake)))
	if err != nil {
		err = msgp.WrapError(err, "Stake")
		return
	}
	for za0002 := range z.Stake {
		err = en.WriteIntf(z.Stake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Stake", za0002)
			return
		}
	}
	// write "ProfitLoss"
	err = en.Append(0xaa, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4c, 0x6f, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProfitLoss)))
	if err != nil {
		err = msgp.WrapError(err, "ProfitLoss")
		return
	}
	for za0003 := range z.ProfitLoss {
		err = en.WriteIntf(z.ProfitLoss[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0003)
			return
		}
	}
	// write "Bets"
	err = en.Append(0xa4, 0x42, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Bets)))
	if err != nil {
		err = msgp.WrapError(err, "Bets")
		return
	}
	for za0004 := range z.Bets {
		err = z.Bets[za0004].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Bets", za0004)
			return
		}
	}
	// write "BetBarValues"
	err = en.Append(0xac, 0x42, 0x65, 0x74, 0x42, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	// map header, size 4
	// write "Success"
	err = en.Append(0x84, 0xa7, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBarValues.Success)))
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues", "Success")
		return
	}
	for za0005 := range z.BetBarValues.Success {
		err = en.WriteIntf(z.BetBarValues.Success[za0005])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Success", za0005)
			return
		}
	}
	// write "Inprogress"
	err = en.Append(0xaa, 0x49, 0x6e, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBarValues.Inprogress)))
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues", "Inprogress")
		return
	}
	for za0006 := range z.BetBarValues.Inprogress {
		err = en.WriteIntf(z.BetBarValues.Inprogress[za0006])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Inprogress", za0006)
			return
		}
	}
	// write "Danger"
	err = en.Append(0xa6, 0x44, 0x61, 0x6e, 0x67, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBarValues.Danger)))
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues", "Danger")
		return
	}
	for za0007 := range z.BetBarValues.Danger {
		err = en.WriteIntf(z.BetBarValues.Danger[za0007])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Danger", za0007)
			return
		}
	}
	// write "Unplaced"
	err = en.Append(0xa8, 0x55, 0x6e, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBarValues.Unplaced)))
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues", "Unplaced")
		return
	}
	for za0008 := range z.BetBarValues.Unplaced {
		err = en.WriteIntf(z.BetBarValues.Unplaced[za0008])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Unplaced", za0008)
			return
		}
	}
	// write "Ts"
	err = en.Append(0xa2, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Ts)
	if err != nil {
		err = msgp.WrapError(err, "Ts")
		return
	}
	// write "BetBookieList"
	err = en.Append(0xad, 0x42, 0x65, 0x74, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x4c, 0x69, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBookieList)))
	if err != nil {
		err = msgp.WrapError(err, "BetBookieList")
		return
	}
	for za0009 := range z.BetBookieList {
		err = en.WriteString(z.BetBookieList[za0009])
		if err != nil {
			err = msgp.WrapError(err, "BetBookieList", za0009)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OrderDataMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 26
	// string "OrderId"
	o = append(o, 0xde, 0x0, 0x1a, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	o = msgp.AppendInt64(o, z.OrderId)
	// string "OrderType"
	o = append(o, 0xa9, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.OrderType)
	// string "BetType"
	o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.BetType)
	// string "BetTypeTemplate"
	o = append(o, 0xaf, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.BetTypeTemplate)
	// string "BetTypeDescription"
	o = append(o, 0xb2, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.BetTypeDescription)
	// string "Sport"
	o = append(o, 0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.Sport)
	// string "Placer"
	o = append(o, 0xa6, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x72)
	o = msgp.AppendString(o, z.Placer)
	// string "WantPrice"
	o = append(o, 0xa9, 0x57, 0x61, 0x6e, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.WantPrice)
	// string "WantStake"
	o = append(o, 0xa9, 0x57, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantStake)))
	for za0001 := range z.WantStake {
		o, err = msgp.AppendIntf(o, z.WantStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0001)
			return
		}
	}
	// string "CcyRate"
	o = append(o, 0xa7, 0x43, 0x63, 0x79, 0x52, 0x61, 0x74, 0x65)
	o = msgp.AppendFloat64(o, z.CcyRate)
	// string "PlacementTime"
	o = append(o, 0xad, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendString(o, z.PlacementTime)
	// string "ExpiryTime"
	o = append(o, 0xaa, 0x45, 0x78, 0x70, 0x69, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ExpiryTime)
	// string "Closed"
	o = append(o, 0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Closed)
	// string "CloseReason"
	o = append(o, 0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.CloseReason)
	// string "EventInfo"
	o = append(o, 0xa9, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f)
	o, err = z.EventInfo.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "EventInfo")
		return
	}
	// string "UserData"
	o = append(o, 0xa8, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendString(o, z.UserData)
	// string "Status"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.Status)
	// string "KeepOpenIr"
	o = append(o, 0xaa, 0x4b, 0x65, 0x65, 0x70, 0x4f, 0x70, 0x65, 0x6e, 0x49, 0x72)
	o = msgp.AppendBool(o, z.KeepOpenIr)
	// string "ExchangeMode"
	o = append(o, 0xac, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x4d, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.ExchangeMode)
	// string "Price"
	o = append(o, 0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.Price)
	// string "Stake"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Stake)))
	for za0002 := range z.Stake {
		o, err = msgp.AppendIntf(o, z.Stake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Stake", za0002)
			return
		}
	}
	// string "ProfitLoss"
	o = append(o, 0xaa, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4c, 0x6f, 0x73, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProfitLoss)))
	for za0003 := range z.ProfitLoss {
		o, err = msgp.AppendIntf(o, z.ProfitLoss[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0003)
			return
		}
	}
	// string "Bets"
	o = append(o, 0xa4, 0x42, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bets)))
	for za0004 := range z.Bets {
		o, err = z.Bets[za0004].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bets", za0004)
			return
		}
	}
	// string "BetBarValues"
	o = append(o, 0xac, 0x42, 0x65, 0x74, 0x42, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	// map header, size 4
	// string "Success"
	o = append(o, 0x84, 0xa7, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBarValues.Success)))
	for za0005 := range z.BetBarValues.Success {
		o, err = msgp.AppendIntf(o, z.BetBarValues.Success[za0005])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Success", za0005)
			return
		}
	}
	// string "Inprogress"
	o = append(o, 0xaa, 0x49, 0x6e, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBarValues.Inprogress)))
	for za0006 := range z.BetBarValues.Inprogress {
		o, err = msgp.AppendIntf(o, z.BetBarValues.Inprogress[za0006])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Inprogress", za0006)
			return
		}
	}
	// string "Danger"
	o = append(o, 0xa6, 0x44, 0x61, 0x6e, 0x67, 0x65, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBarValues.Danger)))
	for za0007 := range z.BetBarValues.Danger {
		o, err = msgp.AppendIntf(o, z.BetBarValues.Danger[za0007])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Danger", za0007)
			return
		}
	}
	// string "Unplaced"
	o = append(o, 0xa8, 0x55, 0x6e, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBarValues.Unplaced)))
	for za0008 := range z.BetBarValues.Unplaced {
		o, err = msgp.AppendIntf(o, z.BetBarValues.Unplaced[za0008])
		if err != nil {
			err = msgp.WrapError(err, "BetBarValues", "Unplaced", za0008)
			return
		}
	}
	// string "Ts"
	o = append(o, 0xa2, 0x54, 0x73)
	o = msgp.AppendFloat64(o, z.Ts)
	// string "BetBookieList"
	o = append(o, 0xad, 0x42, 0x65, 0x74, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x4c, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBookieList)))
	for za0009 := range z.BetBookieList {
		o = msgp.AppendString(o, z.BetBookieList[za0009])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OrderDataMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderId":
			z.OrderId, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "OrderType":
			z.OrderType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderType")
				return
			}
		case "BetType":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "BetTypeTemplate":
			z.BetTypeTemplate, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "BetTypeDescription":
			z.BetTypeDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "Sport":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "Placer":
			z.Placer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Placer")
				return
			}
		case "WantPrice":
			z.WantPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "WantStake":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0002) {
				z.WantStake = (z.WantStake)[:zb0002]
			} else {
				z.WantStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.WantStake {
				z.WantStake[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0001)
					return
				}
			}
		case "CcyRate":
			z.CcyRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "PlacementTime":
			z.PlacementTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlacementTime")
				return
			}
		case "ExpiryTime":
			z.ExpiryTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTime")
				return
			}
		case "Closed":
			z.Closed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "CloseReason":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "EventInfo":
			bts, err = z.EventInfo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventInfo")
				return
			}
		case "UserData":
			z.UserData, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserData")
				return
			}
		case "Status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "KeepOpenIr":
			z.KeepOpenIr, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KeepOpenIr")
				return
			}
		case "ExchangeMode":
			z.ExchangeMode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExchangeMode")
				return
			}
		case "Price":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Stake":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stake")
				return
			}
			if cap(z.Stake) >= int(zb0003) {
				z.Stake = (z.Stake)[:zb0003]
			} else {
				z.Stake = make([]interface{}, zb0003)
			}
			for za0002 := range z.Stake {
				z.Stake[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stake", za0002)
					return
				}
			}
		case "ProfitLoss":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0004) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0004]
			} else {
				z.ProfitLoss = make([]interface{}, zb0004)
			}
			for za0003 := range z.ProfitLoss {
				z.ProfitLoss[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0003)
					return
				}
			}
		case "Bets":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bets")
				return
			}
			if cap(z.Bets) >= int(zb0005) {
				z.Bets = (z.Bets)[:zb0005]
			} else {
				z.Bets = make([]BetMessage, zb0005)
			}
			for za0004 := range z.Bets {
				bts, err = z.Bets[za0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bets", za0004)
					return
				}
			}
		case "BetBarValues":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetBarValues")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "BetBarValues")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Success":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Success")
						return
					}
					if cap(z.BetBarValues.Success) >= int(zb0007) {
						z.BetBarValues.Success = (z.BetBarValues.Success)[:zb0007]
					} else {
						z.BetBarValues.Success = make([]interface{}, zb0007)
					}
					for za0005 := range z.BetBarValues.Success {
						z.BetBarValues.Success[za0005], bts, err = msgp.ReadIntfBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Success", za0005)
							return
						}
					}
				case "Inprogress":
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Inprogress")
						return
					}
					if cap(z.BetBarValues.Inprogress) >= int(zb0008) {
						z.BetBarValues.Inprogress = (z.BetBarValues.Inprogress)[:zb0008]
					} else {
						z.BetBarValues.Inprogress = make([]interface{}, zb0008)
					}
					for za0006 := range z.BetBarValues.Inprogress {
						z.BetBarValues.Inprogress[za0006], bts, err = msgp.ReadIntfBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Inprogress", za0006)
							return
						}
					}
				case "Danger":
					var zb0009 uint32
					zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Danger")
						return
					}
					if cap(z.BetBarValues.Danger) >= int(zb0009) {
						z.BetBarValues.Danger = (z.BetBarValues.Danger)[:zb0009]
					} else {
						z.BetBarValues.Danger = make([]interface{}, zb0009)
					}
					for za0007 := range z.BetBarValues.Danger {
						z.BetBarValues.Danger[za0007], bts, err = msgp.ReadIntfBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Danger", za0007)
							return
						}
					}
				case "Unplaced":
					var zb0010 uint32
					zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues", "Unplaced")
						return
					}
					if cap(z.BetBarValues.Unplaced) >= int(zb0010) {
						z.BetBarValues.Unplaced = (z.BetBarValues.Unplaced)[:zb0010]
					} else {
						z.BetBarValues.Unplaced = make([]interface{}, zb0010)
					}
					for za0008 := range z.BetBarValues.Unplaced {
						z.BetBarValues.Unplaced[za0008], bts, err = msgp.ReadIntfBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BetBarValues", "Unplaced", za0008)
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "BetBarValues")
						return
					}
				}
			}
		case "Ts":
			z.Ts, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		case "BetBookieList":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetBookieList")
				return
			}
			if cap(z.BetBookieList) >= int(zb0011) {
				z.BetBookieList = (z.BetBookieList)[:zb0011]
			} else {
				z.BetBookieList = make([]string, zb0011)
			}
			for za0009 := range z.BetBookieList {
				z.BetBookieList[za0009], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BetBookieList", za0009)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OrderDataMessage) Msgsize() (s int) {
	s = 3 + 8 + msgp.Int64Size + 10 + msgp.StringPrefixSize + len(z.OrderType) + 8 + msgp.StringPrefixSize + len(z.BetType) + 16 + msgp.StringPrefixSize + len(z.BetTypeTemplate) + 19 + msgp.StringPrefixSize + len(z.BetTypeDescription) + 6 + msgp.StringPrefixSize + len(z.Sport) + 7 + msgp.StringPrefixSize + len(z.Placer) + 10 + msgp.Float64Size + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.WantStake {
		s += msgp.GuessSize(z.WantStake[za0001])
	}
	s += 8 + msgp.Float64Size + 14 + msgp.StringPrefixSize + len(z.PlacementTime) + 11 + msgp.StringPrefixSize + len(z.ExpiryTime) + 7 + msgp.BoolSize + 12 + msgp.StringPrefixSize + len(z.CloseReason) + 10 + z.EventInfo.Msgsize() + 9 + msgp.StringPrefixSize + len(z.UserData) + 7 + msgp.StringPrefixSize + len(z.Status) + 11 + msgp.BoolSize + 13 + msgp.StringPrefixSize + len(z.ExchangeMode) + 6 + msgp.Float64Size + 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Stake {
		s += msgp.GuessSize(z.Stake[za0002])
	}
	s += 11 + msgp.ArrayHeaderSize
	for za0003 := range z.ProfitLoss {
		s += msgp.GuessSize(z.ProfitLoss[za0003])
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0004 := range z.Bets {
		s += z.Bets[za0004].Msgsize()
	}
	s += 13 + 1 + 8 + msgp.ArrayHeaderSize
	for za0005 := range z.BetBarValues.Success {
		s += msgp.GuessSize(z.BetBarValues.Success[za0005])
	}
	s += 11 + msgp.ArrayHeaderSize
	for za0006 := range z.BetBarValues.Inprogress {
		s += msgp.GuessSize(z.BetBarValues.Inprogress[za0006])
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0007 := range z.BetBarValues.Danger {
		s += msgp.GuessSize(z.BetBarValues.Danger[za0007])
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0008 := range z.BetBarValues.Unplaced {
		s += msgp.GuessSize(z.BetBarValues.Unplaced[za0008])
	}
	s += 3 + msgp.Float64Size + 14 + msgp.ArrayHeaderSize
	for za0009 := range z.BetBookieList {
		s += msgp.StringPrefixSize + len(z.BetBookieList[za0009])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PmmMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetslipId":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "Sport":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "EventId":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "Bookie":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "Username":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "BetType":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "Status":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Code":
					z.Status.Code, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "Reason":
					z.Status.Reason, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Status", "Reason")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "PriceList":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0003) {
				z.PriceList = (z.PriceList)[:zb0003]
			} else {
				z.PriceList = make([]PriceList, zb0003)
			}
			for za0001 := range z.PriceList {
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "PriceList", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Effective":
						err = z.PriceList[za0001].Effective.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001, "Effective")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001)
							return
						}
					}
				}
			}
		case "Ts":
			z.Ts, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PmmMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "BetslipId"
	err = en.Append(0x89, 0xa9, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "Sport"
	err = en.Append(0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "EventId"
	err = en.Append(0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "Bookie"
	err = en.Append(0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "Username"
	err = en.Append(0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "BetType"
	err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "Status"
	err = en.Append(0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Code"
	err = en.Append(0x82, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status.Code)
	if err != nil {
		err = msgp.WrapError(err, "Status", "Code")
		return
	}
	// write "Reason"
	err = en.Append(0xa6, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status.Reason)
	if err != nil {
		err = msgp.WrapError(err, "Status", "Reason")
		return
	}
	// write "PriceList"
	err = en.Append(0xa9, 0x50, 0x72, 0x69, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PriceList)))
	if err != nil {
		err = msgp.WrapError(err, "PriceList")
		return
	}
	for za0001 := range z.PriceList {
		// map header, size 1
		// write "Effective"
		err = en.Append(0x81, 0xa9, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
		if err != nil {
			return
		}
		err = z.PriceList[za0001].Effective.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001, "Effective")
			return
		}
	}
	// write "Ts"
	err = en.Append(0xa2, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Ts)
	if err != nil {
		err = msgp.WrapError(err, "Ts")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PmmMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "BetslipId"
	o = append(o, 0x89, 0xa9, 0x42, 0x65, 0x74, 0x73, 0x6c, 0x69, 0x70, 0x49, 0x64)
	o = msgp.AppendString(o, z.BetslipId)
	// string "Sport"
	o = append(o, 0xa5, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.Sport)
	// string "EventId"
	o = append(o, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.EventId)
	// string "Bookie"
	o = append(o, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	o = msgp.AppendString(o, z.Bookie)
	// string "Username"
	o = append(o, 0xa8, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	// string "BetType"
	o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.BetType)
	// string "Status"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	// map header, size 2
	// string "Code"
	o = append(o, 0x82, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Status.Code)
	// string "Reason"
	o = append(o, 0xa6, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Status.Reason)
	// string "PriceList"
	o = append(o, 0xa9, 0x50, 0x72, 0x69, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PriceList)))
	for za0001 := range z.PriceList {
		// map header, size 1
		// string "Effective"
		o = append(o, 0x81, 0xa9, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
		o, err = z.PriceList[za0001].Effective.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001, "Effective")
			return
		}
	}
	// string "Ts"
	o = append(o, 0xa2, 0x54, 0x73)
	o = msgp.AppendFloat64(o, z.Ts)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PmmMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BetslipId":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "Sport":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "EventId":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "Bookie":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "Username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "BetType":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "Status":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Code":
					z.Status.Code, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "Reason":
					z.Status.Reason, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status", "Reason")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "PriceList":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0003) {
				z.PriceList = (z.PriceList)[:zb0003]
			} else {
				z.PriceList = make([]PriceList, zb0003)
			}
			for za0001 := range z.PriceList {
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "PriceList", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Effective":
						bts, err = z.PriceList[za0001].Effective.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001, "Effective")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001)
							return
						}
					}
				}
			}
		case "Ts":
			z.Ts, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ts")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PmmMessage) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.BetslipId) + 6 + msgp.StringPrefixSize + len(z.Sport) + 8 + msgp.StringPrefixSize + len(z.EventId) + 7 + msgp.StringPrefixSize + len(z.Bookie) + 9 + msgp.StringPrefixSize + len(z.Username) + 8 + msgp.StringPrefixSize + len(z.BetType) + 7 + 1 + 5 + msgp.StringPrefixSize + len(z.Status.Code) + 7 + msgp.StringPrefixSize + len(z.Status.Reason) + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.PriceList {
		s += 1 + 10 + z.PriceList[za0001].Effective.Msgsize()
	}
	s += 3 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PriceList) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Effective":
			err = z.Effective.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Effective")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PriceList) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Effective"
	err = en.Append(0x81, 0xa9, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	err = z.Effective.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Effective")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PriceList) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Effective"
	o = append(o, 0x81, 0xa9, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	o, err = z.Effective.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Effective")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PriceList) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Effective":
			bts, err = z.Effective.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effective")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PriceList) Msgsize() (s int) {
	s = 1 + 10 + z.Effective.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Result) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "HtHome":
			z.HtHome, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HtHome")
				return
			}
		case "HtAway":
			z.HtAway, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HtAway")
				return
			}
		case "FtHome":
			z.FtHome, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "FtHome")
				return
			}
		case "FtAway":
			z.FtAway, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "FtAway")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Result) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "HtHome"
	err = en.Append(0x84, 0xa6, 0x48, 0x74, 0x48, 0x6f, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HtHome)
	if err != nil {
		err = msgp.WrapError(err, "HtHome")
		return
	}
	// write "HtAway"
	err = en.Append(0xa6, 0x48, 0x74, 0x41, 0x77, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HtAway)
	if err != nil {
		err = msgp.WrapError(err, "HtAway")
		return
	}
	// write "FtHome"
	err = en.Append(0xa6, 0x46, 0x74, 0x48, 0x6f, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.FtHome)
	if err != nil {
		err = msgp.WrapError(err, "FtHome")
		return
	}
	// write "FtAway"
	err = en.Append(0xa6, 0x46, 0x74, 0x41, 0x77, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.FtAway)
	if err != nil {
		err = msgp.WrapError(err, "FtAway")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Result) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "HtHome"
	o = append(o, 0x84, 0xa6, 0x48, 0x74, 0x48, 0x6f, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.HtHome)
	// string "HtAway"
	o = append(o, 0xa6, 0x48, 0x74, 0x41, 0x77, 0x61, 0x79)
	o = msgp.AppendInt(o, z.HtAway)
	// string "FtHome"
	o = append(o, 0xa6, 0x46, 0x74, 0x48, 0x6f, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.FtHome)
	// string "FtAway"
	o = append(o, 0xa6, 0x46, 0x74, 0x41, 0x77, 0x61, 0x79)
	o = msgp.AppendInt(o, z.FtAway)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Result) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "HtHome":
			z.HtHome, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HtHome")
				return
			}
		case "HtAway":
			z.HtAway, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HtAway")
				return
			}
		case "FtHome":
			z.FtHome, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FtHome")
				return
			}
		case "FtAway":
			z.FtAway, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FtAway")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Result) Msgsize() (s int) {
	s = 1 + 7 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Status) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Code":
			z.Code, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "Reason":
			z.Reason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Status) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Code"
	err = en.Append(0x82, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "Reason"
	err = en.Append(0xa6, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Reason)
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Status) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Code"
	o = append(o, 0x82, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Code)
	// string "Reason"
	o = append(o, 0xa6, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Reason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Status) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Code":
			z.Code, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "Reason":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Status) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Code) + 7 + msgp.StringPrefixSize + len(z.Reason)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyncMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Token":
			z.Token, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyncMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Token"
	err = en.Append(0x81, 0xa5, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Token)
	if err != nil {
		err = msgp.WrapError(err, "Token")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyncMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Token"
	o = append(o, 0x81, 0xa5, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyncMessage) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Token)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyncedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "o":
			z.OpenTS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OpenTS")
				return
			}
		case "w":
			z.WsTS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "WsTS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyncedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "u"
	err = en.Append(0x83, 0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.OpenTS)
	if err != nil {
		err = msgp.WrapError(err, "OpenTS")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.WsTS)
	if err != nil {
		err = msgp.WrapError(err, "WsTS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyncedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "u"
	o = append(o, 0x83, 0xa1, 0x75)
	o = msgp.AppendString(o, z.User)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt64(o, z.OpenTS)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendInt64(o, z.WsTS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "o":
			z.OpenTS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenTS")
				return
			}
		case "w":
			z.WsTS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsTS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyncedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.User) + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *User) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.ID, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "u":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "s":
			z.SessionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SessionID")
				return
			}
		case "a":
			z.Active, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *User) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "i"
	err = en.Append(0x84, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.SessionID)
	if err != nil {
		err = msgp.WrapError(err, "SessionID")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Active)
	if err != nil {
		err = msgp.WrapError(err, "Active")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *User) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "i"
	o = append(o, 0x84, 0xa1, 0x69)
	o = msgp.AppendUint16(o, z.ID)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendString(o, z.Username)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.SessionID)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendBool(o, z.Active)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *User) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.ID, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "u":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "s":
			z.SessionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SessionID")
				return
			}
		case "a":
			z.Active, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *User) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint16Size + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.SessionID) + 2 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XRateMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Ccy, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ccy")
				return
			}
		case "r":
			z.Rate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Rate")
				return
			}
		case "t":
			z.TS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z XRateMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "c"
	err = en.Append(0x83, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ccy)
	if err != nil {
		err = msgp.WrapError(err, "Ccy")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Rate)
	if err != nil {
		err = msgp.WrapError(err, "Rate")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z XRateMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "c"
	o = append(o, 0x83, 0xa1, 0x63)
	o = msgp.AppendString(o, z.Ccy)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendFloat64(o, z.Rate)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendFloat64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XRateMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Ccy, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ccy")
				return
			}
		case "r":
			z.Rate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rate")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z XRateMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Ccy) + 2 + msgp.Float64Size + 2 + msgp.Float64Size
	return
}
