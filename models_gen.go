package tbmodels

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Account) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "u":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "t":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Account) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Account) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	o = msgp.AppendString(o, z.Bookie)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendString(o, z.Username)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendString(o, z.BetType)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Account) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "u":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "t":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Account) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.BetType)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BalanceDB) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Balance, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
		case "o":
			z.OpenStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
		case "u":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "i":
			z.UserID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BalanceDB) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "b"
	err = en.Append(0x84, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Balance)
	if err != nil {
		err = msgp.WrapError(err, "Balance")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OpenStake)
	if err != nil {
		err = msgp.WrapError(err, "OpenStake")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	// write "i"
	err = en.Append(0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BalanceDB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "b"
	o = append(o, 0x84, 0xa1, 0x62)
	o = msgp.AppendFloat64(o, z.Balance)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendFloat64(o, z.OpenStake)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendInt64(o, z.TS)
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendUint8(o, z.UserID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BalanceDB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Balance, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
		case "o":
			z.OpenStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
		case "u":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "i":
			z.UserID, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BalanceDB) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int64Size + 2 + msgp.Uint8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BalanceMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
			if cap(z.Balance) >= int(zb0002) {
				z.Balance = (z.Balance)[:zb0002]
			} else {
				z.Balance = make([]interface{}, zb0002)
			}
			for za0001 := range z.Balance {
				z.Balance[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Balance", za0001)
					return
				}
			}
		case "o":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
			if cap(z.OpenStake) >= int(zb0003) {
				z.OpenStake = (z.OpenStake)[:zb0003]
			} else {
				z.OpenStake = make([]interface{}, zb0003)
			}
			for za0002 := range z.OpenStake {
				z.OpenStake[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "OpenStake", za0002)
					return
				}
			}
		case "s":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SmartCredit")
				return
			}
			if cap(z.SmartCredit) >= int(zb0004) {
				z.SmartCredit = (z.SmartCredit)[:zb0004]
			} else {
				z.SmartCredit = make([]interface{}, zb0004)
			}
			for za0003 := range z.SmartCredit {
				z.SmartCredit[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "SmartCredit", za0003)
					return
				}
			}
		case "d":
			z.UserID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BalanceMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "b"
	err = en.Append(0x85, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Balance)))
	if err != nil {
		err = msgp.WrapError(err, "Balance")
		return
	}
	for za0001 := range z.Balance {
		err = en.WriteIntf(z.Balance[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Balance", za0001)
			return
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OpenStake)))
	if err != nil {
		err = msgp.WrapError(err, "OpenStake")
		return
	}
	for za0002 := range z.OpenStake {
		err = en.WriteIntf(z.OpenStake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "OpenStake", za0002)
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SmartCredit)))
	if err != nil {
		err = msgp.WrapError(err, "SmartCredit")
		return
	}
	for za0003 := range z.SmartCredit {
		err = en.WriteIntf(z.SmartCredit[za0003])
		if err != nil {
			err = msgp.WrapError(err, "SmartCredit", za0003)
			return
		}
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BalanceMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "b"
	o = append(o, 0x85, 0xa1, 0x62)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Balance)))
	for za0001 := range z.Balance {
		o, err = msgp.AppendIntf(o, z.Balance[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Balance", za0001)
			return
		}
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OpenStake)))
	for za0002 := range z.OpenStake {
		o, err = msgp.AppendIntf(o, z.OpenStake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "OpenStake", za0002)
			return
		}
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SmartCredit)))
	for za0003 := range z.SmartCredit {
		o, err = msgp.AppendIntf(o, z.SmartCredit[za0003])
		if err != nil {
			err = msgp.WrapError(err, "SmartCredit", za0003)
			return
		}
	}
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendUint8(o, z.UserID)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BalanceMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Balance")
				return
			}
			if cap(z.Balance) >= int(zb0002) {
				z.Balance = (z.Balance)[:zb0002]
			} else {
				z.Balance = make([]interface{}, zb0002)
			}
			for za0001 := range z.Balance {
				z.Balance[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Balance", za0001)
					return
				}
			}
		case "o":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenStake")
				return
			}
			if cap(z.OpenStake) >= int(zb0003) {
				z.OpenStake = (z.OpenStake)[:zb0003]
			} else {
				z.OpenStake = make([]interface{}, zb0003)
			}
			for za0002 := range z.OpenStake {
				z.OpenStake[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OpenStake", za0002)
					return
				}
			}
		case "s":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SmartCredit")
				return
			}
			if cap(z.SmartCredit) >= int(zb0004) {
				z.SmartCredit = (z.SmartCredit)[:zb0004]
			} else {
				z.SmartCredit = make([]interface{}, zb0004)
			}
			for za0003 := range z.SmartCredit {
				z.SmartCredit[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SmartCredit", za0003)
					return
				}
			}
		case "d":
			z.UserID, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BalanceMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Balance {
		s += msgp.GuessSize(z.Balance[za0001])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.OpenStake {
		s += msgp.GuessSize(z.OpenStake[za0002])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.SmartCredit {
		s += msgp.GuessSize(z.SmartCredit[za0003])
	}
	s += 2 + msgp.Uint8Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetBarValues) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Success")
				return
			}
			if cap(z.Success) >= int(zb0002) {
				z.Success = (z.Success)[:zb0002]
			} else {
				z.Success = make([]interface{}, zb0002)
			}
			for za0001 := range z.Success {
				z.Success[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Success", za0001)
					return
				}
			}
		case "i":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Inprogress")
				return
			}
			if cap(z.Inprogress) >= int(zb0003) {
				z.Inprogress = (z.Inprogress)[:zb0003]
			} else {
				z.Inprogress = make([]interface{}, zb0003)
			}
			for za0002 := range z.Inprogress {
				z.Inprogress[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Inprogress", za0002)
					return
				}
			}
		case "d":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Danger")
				return
			}
			if cap(z.Danger) >= int(zb0004) {
				z.Danger = (z.Danger)[:zb0004]
			} else {
				z.Danger = make([]interface{}, zb0004)
			}
			for za0003 := range z.Danger {
				z.Danger[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Danger", za0003)
					return
				}
			}
		case "u":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Unplaced")
				return
			}
			if cap(z.Unplaced) >= int(zb0005) {
				z.Unplaced = (z.Unplaced)[:zb0005]
			} else {
				z.Unplaced = make([]interface{}, zb0005)
			}
			for za0004 := range z.Unplaced {
				z.Unplaced[za0004], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Unplaced", za0004)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BetBarValues) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "s"
	err = en.Append(0x84, 0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Success)))
	if err != nil {
		err = msgp.WrapError(err, "Success")
		return
	}
	for za0001 := range z.Success {
		err = en.WriteIntf(z.Success[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Success", za0001)
			return
		}
	}
	// write "i"
	err = en.Append(0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Inprogress)))
	if err != nil {
		err = msgp.WrapError(err, "Inprogress")
		return
	}
	for za0002 := range z.Inprogress {
		err = en.WriteIntf(z.Inprogress[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Inprogress", za0002)
			return
		}
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Danger)))
	if err != nil {
		err = msgp.WrapError(err, "Danger")
		return
	}
	for za0003 := range z.Danger {
		err = en.WriteIntf(z.Danger[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Danger", za0003)
			return
		}
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Unplaced)))
	if err != nil {
		err = msgp.WrapError(err, "Unplaced")
		return
	}
	for za0004 := range z.Unplaced {
		err = en.WriteIntf(z.Unplaced[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Unplaced", za0004)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BetBarValues) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "s"
	o = append(o, 0x84, 0xa1, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Success)))
	for za0001 := range z.Success {
		o, err = msgp.AppendIntf(o, z.Success[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Success", za0001)
			return
		}
	}
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Inprogress)))
	for za0002 := range z.Inprogress {
		o, err = msgp.AppendIntf(o, z.Inprogress[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Inprogress", za0002)
			return
		}
	}
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Danger)))
	for za0003 := range z.Danger {
		o, err = msgp.AppendIntf(o, z.Danger[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Danger", za0003)
			return
		}
	}
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Unplaced)))
	for za0004 := range z.Unplaced {
		o, err = msgp.AppendIntf(o, z.Unplaced[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Unplaced", za0004)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetBarValues) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Success")
				return
			}
			if cap(z.Success) >= int(zb0002) {
				z.Success = (z.Success)[:zb0002]
			} else {
				z.Success = make([]interface{}, zb0002)
			}
			for za0001 := range z.Success {
				z.Success[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Success", za0001)
					return
				}
			}
		case "i":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Inprogress")
				return
			}
			if cap(z.Inprogress) >= int(zb0003) {
				z.Inprogress = (z.Inprogress)[:zb0003]
			} else {
				z.Inprogress = make([]interface{}, zb0003)
			}
			for za0002 := range z.Inprogress {
				z.Inprogress[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Inprogress", za0002)
					return
				}
			}
		case "d":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Danger")
				return
			}
			if cap(z.Danger) >= int(zb0004) {
				z.Danger = (z.Danger)[:zb0004]
			} else {
				z.Danger = make([]interface{}, zb0004)
			}
			for za0003 := range z.Danger {
				z.Danger[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Danger", za0003)
					return
				}
			}
		case "u":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Unplaced")
				return
			}
			if cap(z.Unplaced) >= int(zb0005) {
				z.Unplaced = (z.Unplaced)[:zb0005]
			} else {
				z.Unplaced = make([]interface{}, zb0005)
			}
			for za0004 := range z.Unplaced {
				z.Unplaced[za0004], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Unplaced", za0004)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BetBarValues) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Success {
		s += msgp.GuessSize(z.Success[za0001])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Inprogress {
		s += msgp.GuessSize(z.Inprogress[za0002])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.Danger {
		s += msgp.GuessSize(z.Danger[za0003])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0004 := range z.Unplaced {
		s += msgp.GuessSize(z.Unplaced[za0004])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetConfig) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "p":
			z.Priority, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Priority")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BetConfig) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "b"
	err = en.Append(0x82, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Priority)
	if err != nil {
		err = msgp.WrapError(err, "Priority")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BetConfig) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "b"
	o = append(o, 0x82, 0xa1, 0x62)
	o = msgp.AppendString(o, z.Bookie)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendInt16(o, z.Priority)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetConfig) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "p":
			z.Priority, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Priority")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BetConfig) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.Int16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.BetID, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BetID")
				return
			}
		case "y":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "k":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "c":
			z.CcyRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "e":
			z.EventID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "g":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "GotPrice")
					return
				}
				z.GotPrice = nil
			} else {
				if z.GotPrice == nil {
					z.GotPrice = new(float64)
				}
				*z.GotPrice, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "GotPrice")
					return
				}
			}
		case "h":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GotStake")
				return
			}
			if cap(z.GotStake) >= int(zb0002) {
				z.GotStake = (z.GotStake)[:zb0002]
			} else {
				z.GotStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.GotStake {
				z.GotStake[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "GotStake", za0001)
					return
				}
			}
		case "o":
			z.OrderID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "p":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0003) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0003]
			} else {
				z.ProfitLoss = make([]interface{}, zb0003)
			}
			for za0002 := range z.ProfitLoss {
				z.ProfitLoss[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0002)
					return
				}
			}
		case "r":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Reconciled")
					return
				}
				z.Reconciled = nil
			} else {
				if z.Reconciled == nil {
					z.Reconciled = new(bool)
				}
				*z.Reconciled, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "Reconciled")
					return
				}
			}
		case "s":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "st":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "c":
					z.Status.Code, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "r":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
						z.Status.Reason = nil
					} else {
						if z.Status.Reason == nil {
							z.Status.Reason = new(string)
						}
						*z.Status.Reason, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "n":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "w":
			z.WantPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "j":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0005) {
				z.WantStake = (z.WantStake)[:zb0005]
			} else {
				z.WantStake = make([]interface{}, zb0005)
			}
			for za0003 := range z.WantStake {
				z.WantStake[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0003)
					return
				}
			}
		case "x":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ExchangeRole")
					return
				}
				z.ExchangeRole = nil
			} else {
				if z.ExchangeRole == nil {
					z.ExchangeRole = new(string)
				}
				*z.ExchangeRole, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ExchangeRole")
					return
				}
			}
		case "O":
			z.OrderCcyRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderCcyRate")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BetMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 18
	// write "i"
	err = en.Append(0xde, 0x0, 0x12, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BetID)
	if err != nil {
		err = msgp.WrapError(err, "BetID")
		return
	}
	// write "y"
	err = en.Append(0xa1, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "k"
	err = en.Append(0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CcyRate)
	if err != nil {
		err = msgp.WrapError(err, "CcyRate")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventID)
	if err != nil {
		err = msgp.WrapError(err, "EventID")
		return
	}
	// write "g"
	err = en.Append(0xa1, 0x67)
	if err != nil {
		return
	}
	if z.GotPrice == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteFloat64(*z.GotPrice)
		if err != nil {
			err = msgp.WrapError(err, "GotPrice")
			return
		}
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GotStake)))
	if err != nil {
		err = msgp.WrapError(err, "GotStake")
		return
	}
	for za0001 := range z.GotStake {
		err = en.WriteIntf(z.GotStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "GotStake", za0001)
			return
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.OrderID)
	if err != nil {
		err = msgp.WrapError(err, "OrderID")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProfitLoss)))
	if err != nil {
		err = msgp.WrapError(err, "ProfitLoss")
		return
	}
	for za0002 := range z.ProfitLoss {
		err = en.WriteIntf(z.ProfitLoss[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0002)
			return
		}
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	if z.Reconciled == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.Reconciled)
		if err != nil {
			err = msgp.WrapError(err, "Reconciled")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "c"
	err = en.Append(0x82, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status.Code)
	if err != nil {
		err = msgp.WrapError(err, "Status", "Code")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	if z.Status.Reason == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.Status.Reason)
		if err != nil {
			err = msgp.WrapError(err, "Status", "Reason")
			return
		}
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WantPrice)
	if err != nil {
		err = msgp.WrapError(err, "WantPrice")
		return
	}
	// write "j"
	err = en.Append(0xa1, 0x6a)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantStake)))
	if err != nil {
		err = msgp.WrapError(err, "WantStake")
		return
	}
	for za0003 := range z.WantStake {
		err = en.WriteIntf(z.WantStake[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0003)
			return
		}
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	if z.ExchangeRole == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.ExchangeRole)
		if err != nil {
			err = msgp.WrapError(err, "ExchangeRole")
			return
		}
	}
	// write "O"
	err = en.Append(0xa1, 0x4f)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderCcyRate)
	if err != nil {
		err = msgp.WrapError(err, "OrderCcyRate")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BetMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "i"
	o = append(o, 0xde, 0x0, 0x12, 0xa1, 0x69)
	o = msgp.AppendInt64(o, z.BetID)
	// string "y"
	o = append(o, 0xa1, 0x79)
	o = msgp.AppendString(o, z.BetType)
	// string "k"
	o = append(o, 0xa1, 0x6b)
	o = msgp.AppendString(o, z.Bookie)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendFloat64(o, z.CcyRate)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendString(o, z.EventID)
	// string "g"
	o = append(o, 0xa1, 0x67)
	if z.GotPrice == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendFloat64(o, *z.GotPrice)
	}
	// string "h"
	o = append(o, 0xa1, 0x68)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GotStake)))
	for za0001 := range z.GotStake {
		o, err = msgp.AppendIntf(o, z.GotStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "GotStake", za0001)
			return
		}
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt32(o, z.OrderID)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProfitLoss)))
	for za0002 := range z.ProfitLoss {
		o, err = msgp.AppendIntf(o, z.ProfitLoss[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0002)
			return
		}
	}
	// string "r"
	o = append(o, 0xa1, 0x72)
	if z.Reconciled == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Reconciled)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Sport)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	// map header, size 2
	// string "c"
	o = append(o, 0x82, 0xa1, 0x63)
	o = msgp.AppendString(o, z.Status.Code)
	// string "r"
	o = append(o, 0xa1, 0x72)
	if z.Status.Reason == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Status.Reason)
	}
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Username)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendFloat64(o, z.WantPrice)
	// string "j"
	o = append(o, 0xa1, 0x6a)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantStake)))
	for za0003 := range z.WantStake {
		o, err = msgp.AppendIntf(o, z.WantStake[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0003)
			return
		}
	}
	// string "x"
	o = append(o, 0xa1, 0x78)
	if z.ExchangeRole == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.ExchangeRole)
	}
	// string "O"
	o = append(o, 0xa1, 0x4f)
	o = msgp.AppendFloat64(o, z.OrderCcyRate)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.BetID, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetID")
				return
			}
		case "y":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "k":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "c":
			z.CcyRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "e":
			z.EventID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "g":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.GotPrice = nil
			} else {
				if z.GotPrice == nil {
					z.GotPrice = new(float64)
				}
				*z.GotPrice, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GotPrice")
					return
				}
			}
		case "h":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GotStake")
				return
			}
			if cap(z.GotStake) >= int(zb0002) {
				z.GotStake = (z.GotStake)[:zb0002]
			} else {
				z.GotStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.GotStake {
				z.GotStake[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GotStake", za0001)
					return
				}
			}
		case "o":
			z.OrderID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "p":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0003) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0003]
			} else {
				z.ProfitLoss = make([]interface{}, zb0003)
			}
			for za0002 := range z.ProfitLoss {
				z.ProfitLoss[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0002)
					return
				}
			}
		case "r":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Reconciled = nil
			} else {
				if z.Reconciled == nil {
					z.Reconciled = new(bool)
				}
				*z.Reconciled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reconciled")
					return
				}
			}
		case "s":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "st":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "c":
					z.Status.Code, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "r":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						z.Status.Reason = nil
					} else {
						if z.Status.Reason == nil {
							z.Status.Reason = new(string)
						}
						*z.Status.Reason, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "n":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "w":
			z.WantPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "j":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0005) {
				z.WantStake = (z.WantStake)[:zb0005]
			} else {
				z.WantStake = make([]interface{}, zb0005)
			}
			for za0003 := range z.WantStake {
				z.WantStake[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0003)
					return
				}
			}
		case "x":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ExchangeRole = nil
			} else {
				if z.ExchangeRole == nil {
					z.ExchangeRole = new(string)
				}
				*z.ExchangeRole, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExchangeRole")
					return
				}
			}
		case "O":
			z.OrderCcyRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderCcyRate")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BetMessage) Msgsize() (s int) {
	s = 3 + 2 + msgp.Int64Size + 2 + msgp.StringPrefixSize + len(z.BetType) + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.Float64Size + 2 + msgp.StringPrefixSize + len(z.EventID) + 2
	if z.GotPrice == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.GotStake {
		s += msgp.GuessSize(z.GotStake[za0001])
	}
	s += 2 + msgp.Int32Size + 2 + msgp.ArrayHeaderSize
	for za0002 := range z.ProfitLoss {
		s += msgp.GuessSize(z.ProfitLoss[za0002])
	}
	s += 2
	if z.Reconciled == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 2 + msgp.StringPrefixSize + len(z.Sport) + 3 + 1 + 2 + msgp.StringPrefixSize + len(z.Status.Code) + 2
	if z.Status.Reason == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Status.Reason)
	}
	s += 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.Float64Size + 2 + msgp.ArrayHeaderSize
	for za0003 := range z.WantStake {
		s += msgp.GuessSize(z.WantStake[za0003])
	}
	s += 2
	if z.ExchangeRole == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.ExchangeRole)
	}
	s += 2 + msgp.Float64Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetslipClosedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "c":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BetslipClosedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BetslipClosedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BetslipId)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendString(o, z.CloseReason)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetslipClosedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "c":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BetslipClosedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.BetslipId) + 2 + msgp.StringPrefixSize + len(z.CloseReason) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BetslipMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "s":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "e":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "t":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "T":
			z.BetTypeTemplate, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "d":
			z.BetTypeDescription, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "x":
			z.ExpiryTs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTs")
				return
			}
		case "is":
			z.IsOpen, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsOpen")
				return
			}
		case "cl":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "a":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Accounts")
				return
			}
			if cap(z.Accounts) >= int(zb0002) {
				z.Accounts = (z.Accounts)[:zb0002]
			} else {
				z.Accounts = make([]Account, zb0002)
			}
			for za0001 := range z.Accounts {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Accounts", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Accounts", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "b":
						z.Accounts[za0001].Bookie, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
							return
						}
					case "u":
						z.Accounts[za0001].Username, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Username")
							return
						}
					case "t":
						z.Accounts[za0001].BetType, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "BetType")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001)
							return
						}
					}
				}
			}
		case "m":
			z.MultipleAccounts, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "MultipleAccounts")
				return
			}
		case "q":
			z.EquivalentBets, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBets")
				return
			}
		case "E":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBetsBookies")
				return
			}
			if cap(z.EquivalentBetsBookies) >= int(zb0004) {
				z.EquivalentBetsBookies = (z.EquivalentBetsBookies)[:zb0004]
			} else {
				z.EquivalentBetsBookies = make([]string, zb0004)
			}
			for za0002 := range z.EquivalentBetsBookies {
				z.EquivalentBetsBookies[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
					return
				}
			}
		case "w":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantBookies")
				return
			}
			if cap(z.WantBookies) >= int(zb0005) {
				z.WantBookies = (z.WantBookies)[:zb0005]
			} else {
				z.WantBookies = make([]string, zb0005)
			}
			for za0003 := range z.WantBookies {
				z.WantBookies[za0003], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "WantBookies", za0003)
					return
				}
			}
		case "o":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BookiesWithOffers")
				return
			}
			if cap(z.BookiesWithOffers) >= int(zb0006) {
				z.BookiesWithOffers = (z.BookiesWithOffers)[:zb0006]
			} else {
				z.BookiesWithOffers = make([]string, zb0006)
			}
			for za0004 := range z.BookiesWithOffers {
				z.BookiesWithOffers[za0004], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BookiesWithOffers", za0004)
					return
				}
			}
		case "n":
			z.CustomerUsername, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CustomerUsername")
				return
			}
		case "c":
			z.CustomerCcy, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CustomerCcy")
				return
			}
		case "y":
			z.BetslipType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipType")
				return
			}
		case "i":
			z.InvalidAccounts, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "InvalidAccounts")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BetslipMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 20
	// write "b"
	err = en.Append(0xde, 0x0, 0x14, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "T"
	err = en.Append(0xa1, 0x54)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeTemplate)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeTemplate")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeDescription)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeDescription")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.ExpiryTs)
	if err != nil {
		err = msgp.WrapError(err, "ExpiryTs")
		return
	}
	// write "is"
	err = en.Append(0xa2, 0x69, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsOpen)
	if err != nil {
		err = msgp.WrapError(err, "IsOpen")
		return
	}
	// write "cl"
	err = en.Append(0xa2, 0x63, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Accounts)))
	if err != nil {
		err = msgp.WrapError(err, "Accounts")
		return
	}
	for za0001 := range z.Accounts {
		// map header, size 3
		// write "b"
		err = en.Append(0x83, 0xa1, 0x62)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].Bookie)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
			return
		}
		// write "u"
		err = en.Append(0xa1, 0x75)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].Username)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "Username")
			return
		}
		// write "t"
		err = en.Append(0xa1, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Accounts[za0001].BetType)
		if err != nil {
			err = msgp.WrapError(err, "Accounts", za0001, "BetType")
			return
		}
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteBool(z.MultipleAccounts)
	if err != nil {
		err = msgp.WrapError(err, "MultipleAccounts")
		return
	}
	// write "q"
	err = en.Append(0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteBool(z.EquivalentBets)
	if err != nil {
		err = msgp.WrapError(err, "EquivalentBets")
		return
	}
	// write "E"
	err = en.Append(0xa1, 0x45)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.EquivalentBetsBookies)))
	if err != nil {
		err = msgp.WrapError(err, "EquivalentBetsBookies")
		return
	}
	for za0002 := range z.EquivalentBetsBookies {
		err = en.WriteString(z.EquivalentBetsBookies[za0002])
		if err != nil {
			err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
			return
		}
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantBookies)))
	if err != nil {
		err = msgp.WrapError(err, "WantBookies")
		return
	}
	for za0003 := range z.WantBookies {
		err = en.WriteString(z.WantBookies[za0003])
		if err != nil {
			err = msgp.WrapError(err, "WantBookies", za0003)
			return
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BookiesWithOffers)))
	if err != nil {
		err = msgp.WrapError(err, "BookiesWithOffers")
		return
	}
	for za0004 := range z.BookiesWithOffers {
		err = en.WriteString(z.BookiesWithOffers[za0004])
		if err != nil {
			err = msgp.WrapError(err, "BookiesWithOffers", za0004)
			return
		}
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CustomerUsername)
	if err != nil {
		err = msgp.WrapError(err, "CustomerUsername")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.CustomerCcy)
	if err != nil {
		err = msgp.WrapError(err, "CustomerCcy")
		return
	}
	// write "y"
	err = en.Append(0xa1, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipType)
	if err != nil {
		err = msgp.WrapError(err, "BetslipType")
		return
	}
	// write "i"
	err = en.Append(0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.InvalidAccounts)
	if err != nil {
		err = msgp.WrapError(err, "InvalidAccounts")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BetslipMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 20
	// string "b"
	o = append(o, 0xde, 0x0, 0x14, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BetslipId)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Sport)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendString(o, z.EventId)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendString(o, z.BetType)
	// string "T"
	o = append(o, 0xa1, 0x54)
	o = msgp.AppendString(o, z.BetTypeTemplate)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendString(o, z.BetTypeDescription)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendFloat64(o, z.ExpiryTs)
	// string "is"
	o = append(o, 0xa2, 0x69, 0x73)
	o = msgp.AppendBool(o, z.IsOpen)
	// string "cl"
	o = append(o, 0xa2, 0x63, 0x6c)
	o = msgp.AppendString(o, z.CloseReason)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Accounts)))
	for za0001 := range z.Accounts {
		// map header, size 3
		// string "b"
		o = append(o, 0x83, 0xa1, 0x62)
		o = msgp.AppendString(o, z.Accounts[za0001].Bookie)
		// string "u"
		o = append(o, 0xa1, 0x75)
		o = msgp.AppendString(o, z.Accounts[za0001].Username)
		// string "t"
		o = append(o, 0xa1, 0x74)
		o = msgp.AppendString(o, z.Accounts[za0001].BetType)
	}
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendBool(o, z.MultipleAccounts)
	// string "q"
	o = append(o, 0xa1, 0x71)
	o = msgp.AppendBool(o, z.EquivalentBets)
	// string "E"
	o = append(o, 0xa1, 0x45)
	o = msgp.AppendArrayHeader(o, uint32(len(z.EquivalentBetsBookies)))
	for za0002 := range z.EquivalentBetsBookies {
		o = msgp.AppendString(o, z.EquivalentBetsBookies[za0002])
	}
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantBookies)))
	for za0003 := range z.WantBookies {
		o = msgp.AppendString(o, z.WantBookies[za0003])
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BookiesWithOffers)))
	for za0004 := range z.BookiesWithOffers {
		o = msgp.AppendString(o, z.BookiesWithOffers[za0004])
	}
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.CustomerUsername)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendString(o, z.CustomerCcy)
	// string "y"
	o = append(o, 0xa1, 0x79)
	o = msgp.AppendString(o, z.BetslipType)
	// string "i"
	o = append(o, 0xa1, 0x69)
	o, err = msgp.AppendIntf(o, z.InvalidAccounts)
	if err != nil {
		err = msgp.WrapError(err, "InvalidAccounts")
		return
	}
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BetslipMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "s":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "e":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "t":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "T":
			z.BetTypeTemplate, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeTemplate")
				return
			}
		case "d":
			z.BetTypeDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "x":
			z.ExpiryTs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTs")
				return
			}
		case "is":
			z.IsOpen, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsOpen")
				return
			}
		case "cl":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "a":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Accounts")
				return
			}
			if cap(z.Accounts) >= int(zb0002) {
				z.Accounts = (z.Accounts)[:zb0002]
			} else {
				z.Accounts = make([]Account, zb0002)
			}
			for za0001 := range z.Accounts {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "b":
						z.Accounts[za0001].Bookie, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Bookie")
							return
						}
					case "u":
						z.Accounts[za0001].Username, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "Username")
							return
						}
					case "t":
						z.Accounts[za0001].BetType, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001, "BetType")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", za0001)
							return
						}
					}
				}
			}
		case "m":
			z.MultipleAccounts, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MultipleAccounts")
				return
			}
		case "q":
			z.EquivalentBets, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBets")
				return
			}
		case "E":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EquivalentBetsBookies")
				return
			}
			if cap(z.EquivalentBetsBookies) >= int(zb0004) {
				z.EquivalentBetsBookies = (z.EquivalentBetsBookies)[:zb0004]
			} else {
				z.EquivalentBetsBookies = make([]string, zb0004)
			}
			for za0002 := range z.EquivalentBetsBookies {
				z.EquivalentBetsBookies[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivalentBetsBookies", za0002)
					return
				}
			}
		case "w":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantBookies")
				return
			}
			if cap(z.WantBookies) >= int(zb0005) {
				z.WantBookies = (z.WantBookies)[:zb0005]
			} else {
				z.WantBookies = make([]string, zb0005)
			}
			for za0003 := range z.WantBookies {
				z.WantBookies[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantBookies", za0003)
					return
				}
			}
		case "o":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BookiesWithOffers")
				return
			}
			if cap(z.BookiesWithOffers) >= int(zb0006) {
				z.BookiesWithOffers = (z.BookiesWithOffers)[:zb0006]
			} else {
				z.BookiesWithOffers = make([]string, zb0006)
			}
			for za0004 := range z.BookiesWithOffers {
				z.BookiesWithOffers[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BookiesWithOffers", za0004)
					return
				}
			}
		case "n":
			z.CustomerUsername, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CustomerUsername")
				return
			}
		case "c":
			z.CustomerCcy, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CustomerCcy")
				return
			}
		case "y":
			z.BetslipType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipType")
				return
			}
		case "i":
			z.InvalidAccounts, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvalidAccounts")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BetslipMessage) Msgsize() (s int) {
	s = 3 + 2 + msgp.StringPrefixSize + len(z.BetslipId) + 2 + msgp.StringPrefixSize + len(z.Sport) + 2 + msgp.StringPrefixSize + len(z.EventId) + 2 + msgp.StringPrefixSize + len(z.BetType) + 2 + msgp.StringPrefixSize + len(z.BetTypeTemplate) + 2 + msgp.StringPrefixSize + len(z.BetTypeDescription) + 2 + msgp.Float64Size + 3 + msgp.BoolSize + 3 + msgp.StringPrefixSize + len(z.CloseReason) + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Accounts {
		s += 1 + 2 + msgp.StringPrefixSize + len(z.Accounts[za0001].Bookie) + 2 + msgp.StringPrefixSize + len(z.Accounts[za0001].Username) + 2 + msgp.StringPrefixSize + len(z.Accounts[za0001].BetType)
	}
	s += 2 + msgp.BoolSize + 2 + msgp.BoolSize + 2 + msgp.ArrayHeaderSize
	for za0002 := range z.EquivalentBetsBookies {
		s += msgp.StringPrefixSize + len(z.EquivalentBetsBookies[za0002])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.WantBookies {
		s += msgp.StringPrefixSize + len(z.WantBookies[za0003])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0004 := range z.BookiesWithOffers {
		s += msgp.StringPrefixSize + len(z.BookiesWithOffers[za0004])
	}
	s += 2 + msgp.StringPrefixSize + len(z.CustomerUsername) + 2 + msgp.StringPrefixSize + len(z.CustomerCcy) + 2 + msgp.StringPrefixSize + len(z.BetslipType) + 2 + msgp.GuessSize(z.InvalidAccounts) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DisconnectedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "x":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DisconnectedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "n"
	err = en.Append(0x82, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteString(z.Error)
	if err != nil {
		err = msgp.WrapError(err, "Error")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DisconnectedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "n"
	o = append(o, 0x82, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Username)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendString(o, z.Error)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DisconnectedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "x":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DisconnectedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DynamicConfigRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DynamicConfigRequest) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "n"
	err = en.Append(0x81, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DynamicConfigRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "n"
	o = append(o, 0x81, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Username)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DynamicConfigRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DynamicConfigRequest) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Username)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DynamicConfigResponse) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			err = z.User.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "a":
			z.UserAgent, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UserAgent")
				return
			}
		case "x":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "c":
						z.Error.Code, err = dc.ReadUint16()
						if err != nil {
							err = msgp.WrapError(err, "Error", "Code")
							return
						}
					case "m":
						z.Error.Msg, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Error", "Msg")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DynamicConfigResponse) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "r"
	err = en.Append(0x83, 0xa1, 0x72)
	if err != nil {
		return
	}
	err = z.User.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(z.UserAgent)
	if err != nil {
		err = msgp.WrapError(err, "UserAgent")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	if z.Error == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "c"
		err = en.Append(0x82, 0xa1, 0x63)
		if err != nil {
			return
		}
		err = en.WriteUint16(z.Error.Code)
		if err != nil {
			err = msgp.WrapError(err, "Error", "Code")
			return
		}
		// write "m"
		err = en.Append(0xa1, 0x6d)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error.Msg)
		if err != nil {
			err = msgp.WrapError(err, "Error", "Msg")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DynamicConfigResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "r"
	o = append(o, 0x83, 0xa1, 0x72)
	o, err = z.User.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendString(o, z.UserAgent)
	// string "x"
	o = append(o, 0xa1, 0x78)
	if z.Error == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "c"
		o = append(o, 0x82, 0xa1, 0x63)
		o = msgp.AppendUint16(o, z.Error.Code)
		// string "m"
		o = append(o, 0xa1, 0x6d)
		o = msgp.AppendString(o, z.Error.Msg)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DynamicConfigResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			bts, err = z.User.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "a":
			z.UserAgent, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserAgent")
				return
			}
		case "x":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "c":
						z.Error.Code, bts, err = msgp.ReadUint16Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Code")
							return
						}
					case "m":
						z.Error.Msg, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Msg")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DynamicConfigResponse) Msgsize() (s int) {
	s = 1 + 2 + z.User.Msgsize() + 2 + msgp.StringPrefixSize + len(z.UserAgent) + 2
	if z.Error == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Uint16Size + 2 + msgp.StringPrefixSize + len(z.Error.Msg)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Effective) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "m":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
			if cap(z.Min) >= int(zb0002) {
				z.Min = (z.Min)[:zb0002]
			} else {
				z.Min = make([]interface{}, zb0002)
			}
			for za0001 := range z.Min {
				z.Min[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Min", za0001)
					return
				}
			}
		case "M":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			if cap(z.Max) >= int(zb0003) {
				z.Max = (z.Max)[:zb0003]
			} else {
				z.Max = make([]interface{}, zb0003)
			}
			for za0002 := range z.Max {
				z.Max[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Max", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Effective) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "p"
	err = en.Append(0x83, 0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Min)))
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	for za0001 := range z.Min {
		err = en.WriteIntf(z.Min[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Min", za0001)
			return
		}
	}
	// write "M"
	err = en.Append(0xa1, 0x4d)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Max)))
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	for za0002 := range z.Max {
		err = en.WriteIntf(z.Max[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Max", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Effective) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "p"
	o = append(o, 0x83, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Min)))
	for za0001 := range z.Min {
		o, err = msgp.AppendIntf(o, z.Min[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Min", za0001)
			return
		}
	}
	// string "M"
	o = append(o, 0xa1, 0x4d)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Max)))
	for za0002 := range z.Max {
		o, err = msgp.AppendIntf(o, z.Max[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Max", za0002)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Effective) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "m":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
			if cap(z.Min) >= int(zb0002) {
				z.Min = (z.Min)[:zb0002]
			} else {
				z.Min = make([]interface{}, zb0002)
			}
			for za0001 := range z.Min {
				z.Min[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Min", za0001)
					return
				}
			}
		case "M":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			if cap(z.Max) >= int(zb0003) {
				z.Max = (z.Max)[:zb0003]
			} else {
				z.Max = make([]interface{}, zb0003)
			}
			for za0002 := range z.Max {
				z.Max[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Max", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Effective) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Min {
		s += msgp.GuessSize(z.Min[za0001])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Max {
		s += msgp.GuessSize(z.Max[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Error) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Code, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "m":
			z.Msg, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Msg")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Error) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "c"
	err = en.Append(0x82, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Msg)
	if err != nil {
		err = msgp.WrapError(err, "Msg")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Error) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "c"
	o = append(o, 0x82, 0xa1, 0x63)
	o = msgp.AppendUint16(o, z.Code)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendString(o, z.Msg)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Error) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Code, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "m":
			z.Msg, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Msg")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Error) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint16Size + 2 + msgp.StringPrefixSize + len(z.Msg)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EventInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "h":
			z.HomeId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HomeId")
				return
			}
		case "H":
			z.HomeTeam, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HomeTeam")
				return
			}
		case "a":
			z.AwayId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AwayId")
				return
			}
		case "A":
			z.AwayTeam, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AwayTeam")
				return
			}
		case "c":
			z.CompetitionId, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionId")
				return
			}
		case "n":
			z.CompetitionName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionName")
				return
			}
		case "y":
			z.CompetitionCountry, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CompetitionCountry")
				return
			}
		case "S":
			z.StartTime, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "D":
			z.Date, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "r":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
			if z.Result == nil {
				z.Result = make(map[string]int, zb0002)
			} else if len(z.Result) > 0 {
				for key := range z.Result {
					delete(z.Result, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 int
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Result")
					return
				}
				za0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Result", za0001)
					return
				}
				z.Result[za0001] = za0002
			}
		case "t":
			z.EventType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventType")
				return
			}
		case "en":
			z.EventName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventName")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *EventInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "i"
	err = en.Append(0x8d, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HomeId)
	if err != nil {
		err = msgp.WrapError(err, "HomeId")
		return
	}
	// write "H"
	err = en.Append(0xa1, 0x48)
	if err != nil {
		return
	}
	err = en.WriteString(z.HomeTeam)
	if err != nil {
		err = msgp.WrapError(err, "HomeTeam")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AwayId)
	if err != nil {
		err = msgp.WrapError(err, "AwayId")
		return
	}
	// write "A"
	err = en.Append(0xa1, 0x41)
	if err != nil {
		return
	}
	err = en.WriteString(z.AwayTeam)
	if err != nil {
		err = msgp.WrapError(err, "AwayTeam")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CompetitionId)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionId")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CompetitionName)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionName")
		return
	}
	// write "y"
	err = en.Append(0xa1, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.CompetitionCountry)
	if err != nil {
		err = msgp.WrapError(err, "CompetitionCountry")
		return
	}
	// write "S"
	err = en.Append(0xa1, 0x53)
	if err != nil {
		return
	}
	err = en.WriteString(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "D"
	err = en.Append(0xa1, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.Date)
	if err != nil {
		err = msgp.WrapError(err, "Date")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Result)))
	if err != nil {
		err = msgp.WrapError(err, "Result")
		return
	}
	for za0001, za0002 := range z.Result {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Result")
			return
		}
		err = en.WriteInt(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Result", za0001)
			return
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventType)
	if err != nil {
		err = msgp.WrapError(err, "EventType")
		return
	}
	// write "en"
	err = en.Append(0xa2, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventName)
	if err != nil {
		err = msgp.WrapError(err, "EventName")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "i"
	o = append(o, 0x8d, 0xa1, 0x69)
	o = msgp.AppendString(o, z.EventId)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o = msgp.AppendInt(o, z.HomeId)
	// string "H"
	o = append(o, 0xa1, 0x48)
	o = msgp.AppendString(o, z.HomeTeam)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendInt(o, z.AwayId)
	// string "A"
	o = append(o, 0xa1, 0x41)
	o = msgp.AppendString(o, z.AwayTeam)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendInt(o, z.CompetitionId)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.CompetitionName)
	// string "y"
	o = append(o, 0xa1, 0x79)
	o = msgp.AppendString(o, z.CompetitionCountry)
	// string "S"
	o = append(o, 0xa1, 0x53)
	o = msgp.AppendString(o, z.StartTime)
	// string "D"
	o = append(o, 0xa1, 0x44)
	o = msgp.AppendString(o, z.Date)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendMapHeader(o, uint32(len(z.Result)))
	for za0001, za0002 := range z.Result {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendInt(o, za0002)
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendString(o, z.EventType)
	// string "en"
	o = append(o, 0xa2, 0x65, 0x6e)
	o = msgp.AppendString(o, z.EventName)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "h":
			z.HomeId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HomeId")
				return
			}
		case "H":
			z.HomeTeam, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HomeTeam")
				return
			}
		case "a":
			z.AwayId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AwayId")
				return
			}
		case "A":
			z.AwayTeam, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AwayTeam")
				return
			}
		case "c":
			z.CompetitionId, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionId")
				return
			}
		case "n":
			z.CompetitionName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionName")
				return
			}
		case "y":
			z.CompetitionCountry, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CompetitionCountry")
				return
			}
		case "S":
			z.StartTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "D":
			z.Date, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "r":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
			if z.Result == nil {
				z.Result = make(map[string]int, zb0002)
			} else if len(z.Result) > 0 {
				for key := range z.Result {
					delete(z.Result, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 int
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Result")
					return
				}
				za0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Result", za0001)
					return
				}
				z.Result[za0001] = za0002
			}
		case "t":
			z.EventType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventType")
				return
			}
		case "en":
			z.EventName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventName")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventInfo) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.EventId) + 2 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.HomeTeam) + 2 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.AwayTeam) + 2 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.CompetitionName) + 2 + msgp.StringPrefixSize + len(z.CompetitionCountry) + 2 + msgp.StringPrefixSize + len(z.StartTime) + 2 + msgp.StringPrefixSize + len(z.Date) + 2 + msgp.MapHeaderSize
	if z.Result != nil {
		for za0001, za0002 := range z.Result {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.IntSize
		}
	}
	s += 2 + msgp.StringPrefixSize + len(z.EventType) + 3 + msgp.StringPrefixSize + len(z.EventName)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InfoMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "q":
			z.QueueSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QueueSize")
				return
			}
		case "m":
			z.QueueSizeMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QueueSizeMax")
				return
			}
		case "r":
			z.RegisteredEvents, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RegisteredEvents")
				return
			}
		case "x":
			z.MaxQueueSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxQueueSize")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *InfoMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "q"
	err = en.Append(0x85, 0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QueueSize)
	if err != nil {
		err = msgp.WrapError(err, "QueueSize")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QueueSizeMax)
	if err != nil {
		err = msgp.WrapError(err, "QueueSizeMax")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RegisteredEvents)
	if err != nil {
		err = msgp.WrapError(err, "RegisteredEvents")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxQueueSize)
	if err != nil {
		err = msgp.WrapError(err, "MaxQueueSize")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InfoMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "q"
	o = append(o, 0x85, 0xa1, 0x71)
	o = msgp.AppendInt(o, z.QueueSize)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendInt(o, z.QueueSizeMax)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendInt(o, z.RegisteredEvents)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendInt(o, z.MaxQueueSize)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InfoMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "q":
			z.QueueSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueueSize")
				return
			}
		case "m":
			z.QueueSizeMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueueSizeMax")
				return
			}
		case "r":
			z.RegisteredEvents, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RegisteredEvents")
				return
			}
		case "x":
			z.MaxQueueSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxQueueSize")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InfoMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NotificationMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "m":
			z.Message, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "l":
			z.Level, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "t":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NotificationMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "n"
	err = en.Append(0x84, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Message)
	if err != nil {
		err = msgp.WrapError(err, "Message")
		return
	}
	// write "l"
	err = en.Append(0xa1, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.Level)
	if err != nil {
		err = msgp.WrapError(err, "Level")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NotificationMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "n"
	o = append(o, 0x84, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Name)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendString(o, z.Message)
	// string "l"
	o = append(o, 0xa1, 0x6c)
	o = msgp.AppendString(o, z.Level)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NotificationMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "m":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "l":
			z.Level, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NotificationMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Name) + 2 + msgp.StringPrefixSize + len(z.Message) + 2 + msgp.StringPrefixSize + len(z.Level) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Offer) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			z.A, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "A")
				return
			}
		case "b":
			z.B, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "B")
				return
			}
		case "c":
			z.C, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "C")
				return
			}
		case "i":
			z.I, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "I")
				return
			}
		case "n":
			z.N, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Offer) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "a"
	err = en.Append(0x85, 0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.A)
	if err != nil {
		err = msgp.WrapError(err, "A")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.B)
	if err != nil {
		err = msgp.WrapError(err, "B")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.C)
	if err != nil {
		err = msgp.WrapError(err, "C")
		return
	}
	// write "i"
	err = en.Append(0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.I)
	if err != nil {
		err = msgp.WrapError(err, "I")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Offer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "a"
	o = append(o, 0x85, 0xa1, 0x61)
	o = msgp.AppendFloat64(o, z.A)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendFloat64(o, z.B)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendFloat64(o, z.C)
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendInt16(o, z.I)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.N)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Offer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			z.A, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "A")
				return
			}
		case "b":
			z.B, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "B")
				return
			}
		case "c":
			z.C, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "C")
				return
			}
		case "i":
			z.I, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "I")
				return
			}
		case "n":
			z.N, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Offer) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int16Size + 2 + msgp.StringPrefixSize + len(z.N)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OffersMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "k":
			err = z.EventKey.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "EventKey")
				return
			}
		case "w":
			z.WsReceive, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "o":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OfferList")
				return
			}
			if cap(z.OfferList) >= int(zb0002) {
				z.OfferList = (z.OfferList)[:zb0002]
			} else {
				z.OfferList = make([]Offer, zb0002)
			}
			for za0001 := range z.OfferList {
				err = z.OfferList[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OfferList", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OffersMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "k"
	err = en.Append(0x83, 0xa1, 0x6b)
	if err != nil {
		return
	}
	err = z.EventKey.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "EventKey")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.WsReceive)
	if err != nil {
		err = msgp.WrapError(err, "WsReceive")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OfferList)))
	if err != nil {
		err = msgp.WrapError(err, "OfferList")
		return
	}
	for za0001 := range z.OfferList {
		err = z.OfferList[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OfferList", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OffersMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "k"
	o = append(o, 0x83, 0xa1, 0x6b)
	o, err = z.EventKey.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "EventKey")
		return
	}
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendInt64(o, z.WsReceive)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OfferList)))
	for za0001 := range z.OfferList {
		o, err = z.OfferList[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "OfferList", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OffersMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "k":
			bts, err = z.EventKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventKey")
				return
			}
		case "w":
			z.WsReceive, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "o":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfferList")
				return
			}
			if cap(z.OfferList) >= int(zb0002) {
				z.OfferList = (z.OfferList)[:zb0002]
			} else {
				z.OfferList = make([]Offer, zb0002)
			}
			for za0001 := range z.OfferList {
				bts, err = z.OfferList[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfferList", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OffersMessage) Msgsize() (s int) {
	s = 1 + 2 + z.EventKey.Msgsize() + 2 + msgp.Int64Size + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.OfferList {
		s += z.OfferList[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OrderDataMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.OrderID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "o":
			z.OrderType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderType")
				return
			}
		case "b":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "d":
			z.BetTypeDescription, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "s":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "p":
			z.Placer, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Placer")
				return
			}
		case "w":
			z.WantPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "k":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0002) {
				z.WantStake = (z.WantStake)[:zb0002]
			} else {
				z.WantStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.WantStake {
				z.WantStake[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0001)
					return
				}
			}
		case "c":
			z.CcyRate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "t":
			z.PlacementTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "PlacementTime")
				return
			}
		case "x":
			z.ExpiryTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTime")
				return
			}
		case "l":
			z.Closed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "r":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "e":
			err = z.EventInfo.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "EventInfo")
				return
			}
		case "n":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "UserData")
					return
				}
				z.UserData = nil
			} else {
				if z.UserData == nil {
					z.UserData = new(string)
				}
				*z.UserData, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "UserData")
					return
				}
			}
		case "q":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "h":
			z.KeepOpenIr, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "KeepOpenIr")
				return
			}
		case "m":
			z.ExchangeMode, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ExchangeMode")
				return
			}
		case "f":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Price")
					return
				}
				z.Price = nil
			} else {
				if z.Price == nil {
					z.Price = new(float64)
				}
				*z.Price, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "Price")
					return
				}
			}
		case "a":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Stake")
				return
			}
			if cap(z.Stake) >= int(zb0003) {
				z.Stake = (z.Stake)[:zb0003]
			} else {
				z.Stake = make([]interface{}, zb0003)
			}
			for za0002 := range z.Stake {
				z.Stake[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Stake", za0002)
					return
				}
			}
		case "z":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0004) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0004]
			} else {
				z.ProfitLoss = make([]interface{}, zb0004)
			}
			for za0003 := range z.ProfitLoss {
				z.ProfitLoss[za0003], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0003)
					return
				}
			}
		case "v":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Bets")
				return
			}
			if cap(z.Bets) >= int(zb0005) {
				z.Bets = (z.Bets)[:zb0005]
			} else {
				z.Bets = make([]BetMessage, zb0005)
			}
			for za0004 := range z.Bets {
				err = z.Bets[za0004].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Bets", za0004)
					return
				}
			}
		case "bb":
			err = z.BetBarValues.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "BetBarValues")
				return
			}
		case "g":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "j":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BetBookieList")
				return
			}
			if cap(z.BetBookieList) >= int(zb0006) {
				z.BetBookieList = (z.BetBookieList)[:zb0006]
			} else {
				z.BetBookieList = make([]string, zb0006)
			}
			for za0005 := range z.BetBookieList {
				z.BetBookieList[za0005], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BetBookieList", za0005)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OrderDataMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 25
	// write "i"
	err = en.Append(0xde, 0x0, 0x19, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.OrderID)
	if err != nil {
		err = msgp.WrapError(err, "OrderID")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderType)
	if err != nil {
		err = msgp.WrapError(err, "OrderType")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetTypeDescription)
	if err != nil {
		err = msgp.WrapError(err, "BetTypeDescription")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.Placer)
	if err != nil {
		err = msgp.WrapError(err, "Placer")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WantPrice)
	if err != nil {
		err = msgp.WrapError(err, "WantPrice")
		return
	}
	// write "k"
	err = en.Append(0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WantStake)))
	if err != nil {
		err = msgp.WrapError(err, "WantStake")
		return
	}
	for za0001 := range z.WantStake {
		err = en.WriteIntf(z.WantStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0001)
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CcyRate)
	if err != nil {
		err = msgp.WrapError(err, "CcyRate")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteTime(z.PlacementTime)
	if err != nil {
		err = msgp.WrapError(err, "PlacementTime")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ExpiryTime)
	if err != nil {
		err = msgp.WrapError(err, "ExpiryTime")
		return
	}
	// write "l"
	err = en.Append(0xa1, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Closed)
	if err != nil {
		err = msgp.WrapError(err, "Closed")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = z.EventInfo.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "EventInfo")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	if z.UserData == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.UserData)
		if err != nil {
			err = msgp.WrapError(err, "UserData")
			return
		}
	}
	// write "q"
	err = en.Append(0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status)
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteBool(z.KeepOpenIr)
	if err != nil {
		err = msgp.WrapError(err, "KeepOpenIr")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.ExchangeMode)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeMode")
		return
	}
	// write "f"
	err = en.Append(0xa1, 0x66)
	if err != nil {
		return
	}
	if z.Price == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteFloat64(*z.Price)
		if err != nil {
			err = msgp.WrapError(err, "Price")
			return
		}
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Stake)))
	if err != nil {
		err = msgp.WrapError(err, "Stake")
		return
	}
	for za0002 := range z.Stake {
		err = en.WriteIntf(z.Stake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Stake", za0002)
			return
		}
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProfitLoss)))
	if err != nil {
		err = msgp.WrapError(err, "ProfitLoss")
		return
	}
	for za0003 := range z.ProfitLoss {
		err = en.WriteIntf(z.ProfitLoss[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0003)
			return
		}
	}
	// write "v"
	err = en.Append(0xa1, 0x76)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Bets)))
	if err != nil {
		err = msgp.WrapError(err, "Bets")
		return
	}
	for za0004 := range z.Bets {
		err = z.Bets[za0004].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Bets", za0004)
			return
		}
	}
	// write "bb"
	err = en.Append(0xa2, 0x62, 0x62)
	if err != nil {
		return
	}
	err = z.BetBarValues.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues")
		return
	}
	// write "g"
	err = en.Append(0xa1, 0x67)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	// write "j"
	err = en.Append(0xa1, 0x6a)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BetBookieList)))
	if err != nil {
		err = msgp.WrapError(err, "BetBookieList")
		return
	}
	for za0005 := range z.BetBookieList {
		err = en.WriteString(z.BetBookieList[za0005])
		if err != nil {
			err = msgp.WrapError(err, "BetBookieList", za0005)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OrderDataMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 25
	// string "i"
	o = append(o, 0xde, 0x0, 0x19, 0xa1, 0x69)
	o = msgp.AppendInt32(o, z.OrderID)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendString(o, z.OrderType)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BetType)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendString(o, z.BetTypeDescription)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Sport)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendString(o, z.Placer)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendFloat64(o, z.WantPrice)
	// string "k"
	o = append(o, 0xa1, 0x6b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WantStake)))
	for za0001 := range z.WantStake {
		o, err = msgp.AppendIntf(o, z.WantStake[za0001])
		if err != nil {
			err = msgp.WrapError(err, "WantStake", za0001)
			return
		}
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendFloat64(o, z.CcyRate)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendTime(o, z.PlacementTime)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendTime(o, z.ExpiryTime)
	// string "l"
	o = append(o, 0xa1, 0x6c)
	o = msgp.AppendBool(o, z.Closed)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendString(o, z.CloseReason)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o, err = z.EventInfo.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "EventInfo")
		return
	}
	// string "n"
	o = append(o, 0xa1, 0x6e)
	if z.UserData == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.UserData)
	}
	// string "q"
	o = append(o, 0xa1, 0x71)
	o = msgp.AppendString(o, z.Status)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o = msgp.AppendBool(o, z.KeepOpenIr)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendString(o, z.ExchangeMode)
	// string "f"
	o = append(o, 0xa1, 0x66)
	if z.Price == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendFloat64(o, *z.Price)
	}
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Stake)))
	for za0002 := range z.Stake {
		o, err = msgp.AppendIntf(o, z.Stake[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Stake", za0002)
			return
		}
	}
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProfitLoss)))
	for za0003 := range z.ProfitLoss {
		o, err = msgp.AppendIntf(o, z.ProfitLoss[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ProfitLoss", za0003)
			return
		}
	}
	// string "v"
	o = append(o, 0xa1, 0x76)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bets)))
	for za0004 := range z.Bets {
		o, err = z.Bets[za0004].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bets", za0004)
			return
		}
	}
	// string "bb"
	o = append(o, 0xa2, 0x62, 0x62)
	o, err = z.BetBarValues.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "BetBarValues")
		return
	}
	// string "g"
	o = append(o, 0xa1, 0x67)
	o = msgp.AppendInt64(o, z.TS)
	// string "j"
	o = append(o, 0xa1, 0x6a)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BetBookieList)))
	for za0005 := range z.BetBookieList {
		o = msgp.AppendString(o, z.BetBookieList[za0005])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OrderDataMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.OrderID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "o":
			z.OrderType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderType")
				return
			}
		case "b":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "d":
			z.BetTypeDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetTypeDescription")
				return
			}
		case "s":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "p":
			z.Placer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Placer")
				return
			}
		case "w":
			z.WantPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantPrice")
				return
			}
		case "k":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WantStake")
				return
			}
			if cap(z.WantStake) >= int(zb0002) {
				z.WantStake = (z.WantStake)[:zb0002]
			} else {
				z.WantStake = make([]interface{}, zb0002)
			}
			for za0001 := range z.WantStake {
				z.WantStake[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WantStake", za0001)
					return
				}
			}
		case "c":
			z.CcyRate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CcyRate")
				return
			}
		case "t":
			z.PlacementTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlacementTime")
				return
			}
		case "x":
			z.ExpiryTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpiryTime")
				return
			}
		case "l":
			z.Closed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "r":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "e":
			bts, err = z.EventInfo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventInfo")
				return
			}
		case "n":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.UserData = nil
			} else {
				if z.UserData == nil {
					z.UserData = new(string)
				}
				*z.UserData, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserData")
					return
				}
			}
		case "q":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "h":
			z.KeepOpenIr, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KeepOpenIr")
				return
			}
		case "m":
			z.ExchangeMode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExchangeMode")
				return
			}
		case "f":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Price = nil
			} else {
				if z.Price == nil {
					z.Price = new(float64)
				}
				*z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Price")
					return
				}
			}
		case "a":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stake")
				return
			}
			if cap(z.Stake) >= int(zb0003) {
				z.Stake = (z.Stake)[:zb0003]
			} else {
				z.Stake = make([]interface{}, zb0003)
			}
			for za0002 := range z.Stake {
				z.Stake[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stake", za0002)
					return
				}
			}
		case "z":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitLoss")
				return
			}
			if cap(z.ProfitLoss) >= int(zb0004) {
				z.ProfitLoss = (z.ProfitLoss)[:zb0004]
			} else {
				z.ProfitLoss = make([]interface{}, zb0004)
			}
			for za0003 := range z.ProfitLoss {
				z.ProfitLoss[za0003], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProfitLoss", za0003)
					return
				}
			}
		case "v":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bets")
				return
			}
			if cap(z.Bets) >= int(zb0005) {
				z.Bets = (z.Bets)[:zb0005]
			} else {
				z.Bets = make([]BetMessage, zb0005)
			}
			for za0004 := range z.Bets {
				bts, err = z.Bets[za0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bets", za0004)
					return
				}
			}
		case "bb":
			bts, err = z.BetBarValues.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetBarValues")
				return
			}
		case "g":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "j":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetBookieList")
				return
			}
			if cap(z.BetBookieList) >= int(zb0006) {
				z.BetBookieList = (z.BetBookieList)[:zb0006]
			} else {
				z.BetBookieList = make([]string, zb0006)
			}
			for za0005 := range z.BetBookieList {
				z.BetBookieList[za0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BetBookieList", za0005)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OrderDataMessage) Msgsize() (s int) {
	s = 3 + 2 + msgp.Int32Size + 2 + msgp.StringPrefixSize + len(z.OrderType) + 2 + msgp.StringPrefixSize + len(z.BetType) + 2 + msgp.StringPrefixSize + len(z.BetTypeDescription) + 2 + msgp.StringPrefixSize + len(z.Sport) + 2 + msgp.StringPrefixSize + len(z.Placer) + 2 + msgp.Float64Size + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.WantStake {
		s += msgp.GuessSize(z.WantStake[za0001])
	}
	s += 2 + msgp.Float64Size + 2 + msgp.TimeSize + 2 + msgp.TimeSize + 2 + msgp.BoolSize + 2 + msgp.StringPrefixSize + len(z.CloseReason) + 2 + z.EventInfo.Msgsize() + 2
	if z.UserData == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.UserData)
	}
	s += 2 + msgp.StringPrefixSize + len(z.Status) + 2 + msgp.BoolSize + 2 + msgp.StringPrefixSize + len(z.ExchangeMode) + 2
	if z.Price == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Stake {
		s += msgp.GuessSize(z.Stake[za0002])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.ProfitLoss {
		s += msgp.GuessSize(z.ProfitLoss[za0003])
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0004 := range z.Bets {
		s += z.Bets[za0004].Msgsize()
	}
	s += 3 + z.BetBarValues.Msgsize() + 2 + msgp.Int64Size + 2 + msgp.ArrayHeaderSize
	for za0005 := range z.BetBookieList {
		s += msgp.StringPrefixSize + len(z.BetBookieList[za0005])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OrdersMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Orders")
				return
			}
			if cap(z.Orders) >= int(zb0002) {
				z.Orders = (z.Orders)[:zb0002]
			} else {
				z.Orders = make([]OrderDataMessage, zb0002)
			}
			for za0001 := range z.Orders {
				err = z.Orders[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Orders", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OrdersMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "o"
	err = en.Append(0x81, 0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Orders)))
	if err != nil {
		err = msgp.WrapError(err, "Orders")
		return
	}
	for za0001 := range z.Orders {
		err = z.Orders[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Orders", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OrdersMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "o"
	o = append(o, 0x81, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Orders)))
	for za0001 := range z.Orders {
		o, err = z.Orders[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Orders", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OrdersMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Orders")
				return
			}
			if cap(z.Orders) >= int(zb0002) {
				z.Orders = (z.Orders)[:zb0002]
			} else {
				z.Orders = make([]OrderDataMessage, zb0002)
			}
			for za0001 := range z.Orders {
				bts, err = z.Orders[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Orders", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OrdersMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Orders {
		s += z.Orders[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OrdersResponse) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "d":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			if cap(z.Data) >= int(zb0002) {
				z.Data = (z.Data)[:zb0002]
			} else {
				z.Data = make([]OrderDataMessage, zb0002)
			}
			for za0001 := range z.Data {
				err = z.Data[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Data", za0001)
					return
				}
			}
		case "s":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OrdersResponse) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "d"
	err = en.Append(0x82, 0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Data)))
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	for za0001 := range z.Data {
		err = z.Data[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Data", za0001)
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status)
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OrdersResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "d"
	o = append(o, 0x82, 0xa1, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Data)))
	for za0001 := range z.Data {
		o, err = z.Data[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Data", za0001)
			return
		}
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Status)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OrdersResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "d":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			if cap(z.Data) >= int(zb0002) {
				z.Data = (z.Data)[:zb0002]
			} else {
				z.Data = make([]OrderDataMessage, zb0002)
			}
			for za0001 := range z.Data {
				bts, err = z.Data[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Data", za0001)
					return
				}
			}
		case "s":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OrdersResponse) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Data {
		s += z.Data[za0001].Msgsize()
	}
	s += 2 + msgp.StringPrefixSize + len(z.Status)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PingMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PingMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PingMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PingMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PingMessage) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PmmMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "s":
			z.Sport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "e":
			z.EventId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "B":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "n":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "t":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "st":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "c":
					z.Status.Code, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "r":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
						z.Status.Reason = nil
					} else {
						if z.Status.Reason == nil {
							z.Status.Reason = new(string)
						}
						*z.Status.Reason, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "p":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0003) {
				z.PriceList = (z.PriceList)[:zb0003]
			} else {
				z.PriceList = make([]PriceList, zb0003)
			}
			for za0001 := range z.PriceList {
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "PriceList", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "v":
						err = z.PriceList[za0001].Effective.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001, "Effective")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001)
							return
						}
					}
				}
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PmmMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "b"
	err = en.Append(0x89, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetslipId)
	if err != nil {
		err = msgp.WrapError(err, "BetslipId")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sport)
	if err != nil {
		err = msgp.WrapError(err, "Sport")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventId)
	if err != nil {
		err = msgp.WrapError(err, "EventId")
		return
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "c"
	err = en.Append(0x82, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status.Code)
	if err != nil {
		err = msgp.WrapError(err, "Status", "Code")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	if z.Status.Reason == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.Status.Reason)
		if err != nil {
			err = msgp.WrapError(err, "Status", "Reason")
			return
		}
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PriceList)))
	if err != nil {
		err = msgp.WrapError(err, "PriceList")
		return
	}
	for za0001 := range z.PriceList {
		// map header, size 1
		// write "v"
		err = en.Append(0x81, 0xa1, 0x76)
		if err != nil {
			return
		}
		err = z.PriceList[za0001].Effective.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001, "Effective")
			return
		}
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PmmMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "b"
	o = append(o, 0x89, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BetslipId)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Sport)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendString(o, z.EventId)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendString(o, z.Bookie)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Username)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendString(o, z.BetType)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	// map header, size 2
	// string "c"
	o = append(o, 0x82, 0xa1, 0x63)
	o = msgp.AppendString(o, z.Status.Code)
	// string "r"
	o = append(o, 0xa1, 0x72)
	if z.Status.Reason == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Status.Reason)
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PriceList)))
	for za0001 := range z.PriceList {
		// map header, size 1
		// string "v"
		o = append(o, 0x81, 0xa1, 0x76)
		o, err = z.PriceList[za0001].Effective.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001, "Effective")
			return
		}
	}
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PmmMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.BetslipId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetslipId")
				return
			}
		case "s":
			z.Sport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sport")
				return
			}
		case "e":
			z.EventId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventId")
				return
			}
		case "B":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "n":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "t":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "st":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				switch msgp.UnsafeString(field) {
				case "c":
					z.Status.Code, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status", "Code")
						return
					}
				case "r":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						z.Status.Reason = nil
					} else {
						if z.Status.Reason == nil {
							z.Status.Reason = new(string)
						}
						*z.Status.Reason, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status", "Reason")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
				}
			}
		case "p":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0003) {
				z.PriceList = (z.PriceList)[:zb0003]
			} else {
				z.PriceList = make([]PriceList, zb0003)
			}
			for za0001 := range z.PriceList {
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "PriceList", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "v":
						bts, err = z.PriceList[za0001].Effective.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001, "Effective")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "PriceList", za0001)
							return
						}
					}
				}
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PmmMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.BetslipId) + 2 + msgp.StringPrefixSize + len(z.Sport) + 2 + msgp.StringPrefixSize + len(z.EventId) + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.BetType) + 3 + 1 + 2 + msgp.StringPrefixSize + len(z.Status.Code) + 2
	if z.Status.Reason == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Status.Reason)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.PriceList {
		s += 1 + 2 + z.PriceList[za0001].Effective.Msgsize()
	}
	s += 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PriceList) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "v":
			err = z.Effective.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Effective")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PriceList) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "v"
	err = en.Append(0x81, 0xa1, 0x76)
	if err != nil {
		return
	}
	err = z.Effective.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Effective")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PriceList) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "v"
	o = append(o, 0x81, 0xa1, 0x76)
	o, err = z.Effective.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Effective")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PriceList) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "v":
			bts, err = z.Effective.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effective")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PriceList) Msgsize() (s int) {
	s = 1 + 2 + z.Effective.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ServiceMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "v":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "s":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "u":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "t":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ServiceMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "n"
	err = en.Append(0x85, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "v"
	err = en.Append(0xa1, 0x76)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Status)
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServiceMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "n"
	o = append(o, 0x85, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Name)
	// string "v"
	o = append(o, 0xa1, 0x76)
	o = msgp.AppendString(o, z.Version)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.Status)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendString(o, z.User)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServiceMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "v":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "s":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "u":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServiceMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Name) + 2 + msgp.StringPrefixSize + len(z.Version) + 2 + msgp.StringPrefixSize + len(z.Status) + 2 + msgp.StringPrefixSize + len(z.User) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SettingsMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Settings")
				return
			}
			if z.Settings == nil {
				z.Settings = make(map[string]string, zb0002)
			} else if len(z.Settings) > 0 {
				for key := range z.Settings {
					delete(z.Settings, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Settings")
					return
				}
				za0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Settings", za0001)
					return
				}
				z.Settings[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SettingsMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "s"
	err = en.Append(0x81, 0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Settings)))
	if err != nil {
		err = msgp.WrapError(err, "Settings")
		return
	}
	for za0001, za0002 := range z.Settings {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Settings")
			return
		}
		err = en.WriteString(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Settings", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SettingsMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "s"
	o = append(o, 0x81, 0xa1, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Settings)))
	for za0001, za0002 := range z.Settings {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendString(o, za0002)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SettingsMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Settings")
				return
			}
			if z.Settings == nil {
				z.Settings = make(map[string]string, zb0002)
			} else if len(z.Settings) > 0 {
				for key := range z.Settings {
					delete(z.Settings, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 string
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Settings")
					return
				}
				za0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Settings", za0001)
					return
				}
				z.Settings[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SettingsMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.MapHeaderSize
	if z.Settings != nil {
		for za0001, za0002 := range z.Settings {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.StringPrefixSize + len(za0002)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StatsMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "e":
			z.EventID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "t":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "d":
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StatsMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "e"
	err = en.Append(0x83, 0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.EventID)
	if err != nil {
		err = msgp.WrapError(err, "EventID")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StatsMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "e"
	o = append(o, 0x83, 0xa1, 0x65)
	o = msgp.AppendInt32(o, z.EventID)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.TS)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StatsMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "e":
			z.EventID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "d":
			z.Data, bts, err = msgp.ReadBytesBytes(bts, z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StatsMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int32Size + 2 + msgp.Int64Size + 2 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Status) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Code, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "r":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
				z.Reason = nil
			} else {
				if z.Reason == nil {
					z.Reason = new(string)
				}
				*z.Reason, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Status) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "c"
	err = en.Append(0x82, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	if z.Reason == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.Reason)
		if err != nil {
			err = msgp.WrapError(err, "Reason")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Status) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "c"
	o = append(o, 0x82, 0xa1, 0x63)
	o = msgp.AppendString(o, z.Code)
	// string "r"
	o = append(o, 0xa1, 0x72)
	if z.Reason == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Reason)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Status) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Code, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "r":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Reason = nil
			} else {
				if z.Reason == nil {
					z.Reason = new(string)
				}
				*z.Reason, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Status) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Code) + 2
	if z.Reason == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Reason)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyncMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "k":
			z.Token, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyncMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "k"
	err = en.Append(0x82, 0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteString(z.Token)
	if err != nil {
		err = msgp.WrapError(err, "Token")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyncMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "k"
	o = append(o, 0x82, 0xa1, 0x6b)
	o = msgp.AppendString(o, z.Token)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "k":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyncMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Token) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyncedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "o":
			z.OpenTS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OpenTS")
				return
			}
		case "w":
			z.WsTS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "WsTS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyncedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "n"
	err = en.Append(0x83, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.OpenTS)
	if err != nil {
		err = msgp.WrapError(err, "OpenTS")
		return
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.WsTS)
	if err != nil {
		err = msgp.WrapError(err, "WsTS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyncedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "n"
	o = append(o, 0x83, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.User)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt64(o, z.OpenTS)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendInt64(o, z.WsTS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "o":
			z.OpenTS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenTS")
				return
			}
		case "w":
			z.WsTS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsTS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyncedMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.User) + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Timing) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			z.WsReceive, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "p":
			z.BeginProcess, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginProcess")
				return
			}
		case "u":
			z.BeginSubmit, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginSubmit")
				return
			}
		case "j":
			z.BeginJob, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginJob")
				return
			}
		case "o":
			z.BeginOpen, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginOpen")
				return
			}
		case "e":
			z.EndOpen, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndOpen")
				return
			}
		case "s":
			z.BeginCheck, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginCheck")
				return
			}
		case "t":
			z.BeginStats, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginStats")
				return
			}
		case "a":
			z.EndStats, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndStats")
				return
			}
		case "c":
			z.FirstComplete, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FirstComplete")
				return
			}
		case "k":
			z.ConditionsOk, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ConditionsOk")
				return
			}
		case "b":
			z.BeginFirstBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginFirstBet")
				return
			}
		case "n":
			z.EndFirstBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndFirstBet")
				return
			}
		case "f":
			z.BeginCalcSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginCalcSecondBet")
				return
			}
		case "d":
			z.BeginSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginSecondBet")
				return
			}
		case "m":
			z.EndSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndSecondBet")
				return
			}
		case "x":
			z.BeginExit, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginExit")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Timing) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 17
	// write "r"
	err = en.Append(0xde, 0x0, 0x11, 0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.WsReceive)
	if err != nil {
		err = msgp.WrapError(err, "WsReceive")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginProcess)
	if err != nil {
		err = msgp.WrapError(err, "BeginProcess")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginSubmit)
	if err != nil {
		err = msgp.WrapError(err, "BeginSubmit")
		return
	}
	// write "j"
	err = en.Append(0xa1, 0x6a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginJob)
	if err != nil {
		err = msgp.WrapError(err, "BeginJob")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginOpen)
	if err != nil {
		err = msgp.WrapError(err, "BeginOpen")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndOpen)
	if err != nil {
		err = msgp.WrapError(err, "EndOpen")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginCheck)
	if err != nil {
		err = msgp.WrapError(err, "BeginCheck")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginStats)
	if err != nil {
		err = msgp.WrapError(err, "BeginStats")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndStats)
	if err != nil {
		err = msgp.WrapError(err, "EndStats")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.FirstComplete)
	if err != nil {
		err = msgp.WrapError(err, "FirstComplete")
		return
	}
	// write "k"
	err = en.Append(0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ConditionsOk)
	if err != nil {
		err = msgp.WrapError(err, "ConditionsOk")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginFirstBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginFirstBet")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndFirstBet)
	if err != nil {
		err = msgp.WrapError(err, "EndFirstBet")
		return
	}
	// write "f"
	err = en.Append(0xa1, 0x66)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginCalcSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginCalcSecondBet")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginSecondBet")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "EndSecondBet")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginExit)
	if err != nil {
		err = msgp.WrapError(err, "BeginExit")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Timing) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "r"
	o = append(o, 0xde, 0x0, 0x11, 0xa1, 0x72)
	o = msgp.AppendInt64(o, z.WsReceive)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendInt64(o, z.BeginProcess)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendInt64(o, z.BeginSubmit)
	// string "j"
	o = append(o, 0xa1, 0x6a)
	o = msgp.AppendInt64(o, z.BeginJob)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt64(o, z.BeginOpen)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendInt64(o, z.EndOpen)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendInt64(o, z.BeginCheck)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.BeginStats)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.EndStats)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendInt64(o, z.FirstComplete)
	// string "k"
	o = append(o, 0xa1, 0x6b)
	o = msgp.AppendInt64(o, z.ConditionsOk)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendInt64(o, z.BeginFirstBet)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendInt64(o, z.EndFirstBet)
	// string "f"
	o = append(o, 0xa1, 0x66)
	o = msgp.AppendInt64(o, z.BeginCalcSecondBet)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt64(o, z.BeginSecondBet)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendInt64(o, z.EndSecondBet)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendInt64(o, z.BeginExit)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Timing) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			z.WsReceive, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "p":
			z.BeginProcess, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginProcess")
				return
			}
		case "u":
			z.BeginSubmit, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginSubmit")
				return
			}
		case "j":
			z.BeginJob, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginJob")
				return
			}
		case "o":
			z.BeginOpen, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginOpen")
				return
			}
		case "e":
			z.EndOpen, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndOpen")
				return
			}
		case "s":
			z.BeginCheck, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginCheck")
				return
			}
		case "t":
			z.BeginStats, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginStats")
				return
			}
		case "a":
			z.EndStats, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndStats")
				return
			}
		case "c":
			z.FirstComplete, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FirstComplete")
				return
			}
		case "k":
			z.ConditionsOk, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConditionsOk")
				return
			}
		case "b":
			z.BeginFirstBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginFirstBet")
				return
			}
		case "n":
			z.EndFirstBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndFirstBet")
				return
			}
		case "f":
			z.BeginCalcSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginCalcSecondBet")
				return
			}
		case "d":
			z.BeginSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginSecondBet")
				return
			}
		case "m":
			z.EndSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndSecondBet")
				return
			}
		case "x":
			z.BeginExit, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginExit")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Timing) Msgsize() (s int) {
	s = 3 + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *User) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.ID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "u":
			z.Username, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "s":
			z.SessionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SessionID")
				return
			}
		case "a":
			z.Active, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *User) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "i"
	err = en.Append(0x84, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteString(z.Username)
	if err != nil {
		err = msgp.WrapError(err, "Username")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.SessionID)
	if err != nil {
		err = msgp.WrapError(err, "SessionID")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Active)
	if err != nil {
		err = msgp.WrapError(err, "Active")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *User) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "i"
	o = append(o, 0x84, 0xa1, 0x69)
	o = msgp.AppendUint8(o, z.ID)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendString(o, z.Username)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendString(o, z.SessionID)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendBool(o, z.Active)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *User) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			z.ID, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "u":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "s":
			z.SessionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SessionID")
				return
			}
		case "a":
			z.Active, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *User) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 2 + msgp.StringPrefixSize + len(z.Username) + 2 + msgp.StringPrefixSize + len(z.SessionID) + 2 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XRateMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Ccy, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Ccy")
				return
			}
		case "r":
			z.Rate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Rate")
				return
			}
		case "z":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z XRateMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "c"
	err = en.Append(0x83, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Ccy)
	if err != nil {
		err = msgp.WrapError(err, "Ccy")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Rate)
	if err != nil {
		err = msgp.WrapError(err, "Rate")
		return
	}
	// write "z"
	err = en.Append(0xa1, 0x7a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z XRateMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "c"
	o = append(o, 0x83, 0xa1, 0x63)
	o = msgp.AppendString(o, z.Ccy)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendFloat64(o, z.Rate)
	// string "z"
	o = append(o, 0xa1, 0x7a)
	o = msgp.AppendInt64(o, z.TS)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XRateMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			z.Ccy, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ccy")
				return
			}
		case "r":
			z.Rate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rate")
				return
			}
		case "z":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z XRateMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Ccy) + 2 + msgp.Float64Size + 2 + msgp.Int64Size
	return
}
