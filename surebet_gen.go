package tbmodels

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Price) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "e":
			z.BetType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "P":
			z.BestPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BestPrice")
				return
			}
		case "l":
			z.LowestPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LowestPrice")
				return
			}
		case "m":
			z.Min, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "M":
			z.Max, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		case "t":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "a":
			z.AgeMS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "AgeMS")
				return
			}
		case "f":
			z.FailProb, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "FailProb")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Price) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "b"
	err = en.Append(0x8a, 0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetType)
	if err != nil {
		err = msgp.WrapError(err, "BetType")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "P"
	err = en.Append(0xa1, 0x50)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BestPrice)
	if err != nil {
		err = msgp.WrapError(err, "BestPrice")
		return
	}
	// write "l"
	err = en.Append(0xa1, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.LowestPrice)
	if err != nil {
		err = msgp.WrapError(err, "LowestPrice")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Min)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	// write "M"
	err = en.Append(0xa1, 0x4d)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Max)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.AgeMS)
	if err != nil {
		err = msgp.WrapError(err, "AgeMS")
		return
	}
	// write "f"
	err = en.Append(0xa1, 0x66)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.FailProb)
	if err != nil {
		err = msgp.WrapError(err, "FailProb")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Price) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "b"
	o = append(o, 0x8a, 0xa1, 0x62)
	o = msgp.AppendString(o, z.Bookie)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendString(o, z.BetType)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "P"
	o = append(o, 0xa1, 0x50)
	o = msgp.AppendFloat64(o, z.BestPrice)
	// string "l"
	o = append(o, 0xa1, 0x6c)
	o = msgp.AppendFloat64(o, z.LowestPrice)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendFloat64(o, z.Min)
	// string "M"
	o = append(o, 0xa1, 0x4d)
	o = msgp.AppendFloat64(o, z.Max)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.TS)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.AgeMS)
	// string "f"
	o = append(o, 0xa1, 0x66)
	o = msgp.AppendFloat64(o, z.FailProb)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Price) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "e":
			z.BetType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetType")
				return
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "P":
			z.BestPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BestPrice")
				return
			}
		case "l":
			z.LowestPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LowestPrice")
				return
			}
		case "m":
			z.Min, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "M":
			z.Max, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		case "t":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "a":
			z.AgeMS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AgeMS")
				return
			}
		case "f":
			z.FailProb, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailProb")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Price) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.StringPrefixSize + len(z.BetType) + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Side) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ca":
			z.CreatedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "l":
			z.LastData, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastData")
				return
			}
		case "n":
			z.BetName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetName")
				return
			}
		case "cr":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "os":
			z.OrderStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderStatus")
				return
			}
		case "b":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "r":
			z.MaxReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MaxReason")
				return
			}
		case "q":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0002) {
				z.PriceList = (z.PriceList)[:zb0002]
			} else {
				z.PriceList = make([]Price, zb0002)
			}
			for za0001 := range z.PriceList {
				err = z.PriceList[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
			}
		case "w":
			z.MinWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinWin")
				return
			}
		case "F":
			z.FreeBalance, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "FreeBalance")
				return
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "M":
			z.CheckMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckMax")
				return
			}
		case "m":
			z.CheckMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckMin")
				return
			}
		case "x":
			z.Xrate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Xrate")
				return
			}
		case "B":
			z.BackupPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BackupPrice")
				return
			}
		case "s":
			z.OrderStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderStake")
				return
			}
		case "T":
			z.OrderPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderPrice")
				return
			}
		case "S":
			z.MinStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinStake")
				return
			}
		case "h":
			z.MaxStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxStake")
				return
			}
		case "N":
			z.BetPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetPrice")
				return
			}
		case "j":
			z.BetStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetStake")
				return
			}
		case "c":
			z.CheckPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckPrice")
				return
			}
		case "X":
			z.MaxPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPercent")
				return
			}
		case "W":
			z.MaxWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxWin")
				return
			}
		case "O":
			z.BetWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetWin")
				return
			}
		case "Y":
			z.MinPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinPercent")
				return
			}
		case "R":
			z.FillFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "FillFactor")
				return
			}
		case "e":
			z.EventFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "EventFactor")
				return
			}
		case "V":
			z.VoidFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "VoidFactor")
				return
			}
		case "sf":
			z.StatsFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "StatsFactor")
				return
			}
		case "U":
			z.ProfitMultiplier, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ProfitMultiplier")
				return
			}
		case "Z":
			z.WeightedPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedPrice")
				return
			}
		case "v":
			z.WeightedVolume, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedVolume")
				return
			}
		case "d":
			z.WeightedDistance, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedDistance")
				return
			}
		case "Q":
			z.OrderID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "o":
			z.Offers, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Offers")
				return
			}
		case "i":
			z.Index, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "t":
			z.TryBetCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "TryBetCount")
				return
			}
		case "k":
			z.BackupCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "BackupCount")
				return
			}
		case "P":
			z.PriceCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "PriceCount")
				return
			}
		case "a":
			z.Age, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "f":
			z.IsFirst, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsFirst")
				return
			}
		case "u":
			z.UserID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "g":
			z.IsComplete, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsComplete")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Side) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 44
	// write "ca"
	err = en.Append(0xde, 0x0, 0x2c, 0xa2, 0x63, 0x61)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CreatedAt)
	if err != nil {
		err = msgp.WrapError(err, "CreatedAt")
		return
	}
	// write "l"
	err = en.Append(0xa1, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastData)
	if err != nil {
		err = msgp.WrapError(err, "LastData")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetName)
	if err != nil {
		err = msgp.WrapError(err, "BetName")
		return
	}
	// write "cr"
	err = en.Append(0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "os"
	err = en.Append(0xa2, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderStatus)
	if err != nil {
		err = msgp.WrapError(err, "OrderStatus")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.MaxReason)
	if err != nil {
		err = msgp.WrapError(err, "MaxReason")
		return
	}
	// write "q"
	err = en.Append(0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PriceList)))
	if err != nil {
		err = msgp.WrapError(err, "PriceList")
		return
	}
	for za0001 := range z.PriceList {
		err = z.PriceList[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001)
			return
		}
	}
	// write "w"
	err = en.Append(0xa1, 0x77)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinWin)
	if err != nil {
		err = msgp.WrapError(err, "MinWin")
		return
	}
	// write "F"
	err = en.Append(0xa1, 0x46)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.FreeBalance)
	if err != nil {
		err = msgp.WrapError(err, "FreeBalance")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "M"
	err = en.Append(0xa1, 0x4d)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckMax)
	if err != nil {
		err = msgp.WrapError(err, "CheckMax")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckMin)
	if err != nil {
		err = msgp.WrapError(err, "CheckMin")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Xrate)
	if err != nil {
		err = msgp.WrapError(err, "Xrate")
		return
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BackupPrice)
	if err != nil {
		err = msgp.WrapError(err, "BackupPrice")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderStake)
	if err != nil {
		err = msgp.WrapError(err, "OrderStake")
		return
	}
	// write "T"
	err = en.Append(0xa1, 0x54)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderPrice)
	if err != nil {
		err = msgp.WrapError(err, "OrderPrice")
		return
	}
	// write "S"
	err = en.Append(0xa1, 0x53)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinStake)
	if err != nil {
		err = msgp.WrapError(err, "MinStake")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxStake)
	if err != nil {
		err = msgp.WrapError(err, "MaxStake")
		return
	}
	// write "N"
	err = en.Append(0xa1, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetPrice)
	if err != nil {
		err = msgp.WrapError(err, "BetPrice")
		return
	}
	// write "j"
	err = en.Append(0xa1, 0x6a)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetStake)
	if err != nil {
		err = msgp.WrapError(err, "BetStake")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckPrice)
	if err != nil {
		err = msgp.WrapError(err, "CheckPrice")
		return
	}
	// write "X"
	err = en.Append(0xa1, 0x58)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxPercent)
	if err != nil {
		err = msgp.WrapError(err, "MaxPercent")
		return
	}
	// write "W"
	err = en.Append(0xa1, 0x57)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxWin)
	if err != nil {
		err = msgp.WrapError(err, "MaxWin")
		return
	}
	// write "O"
	err = en.Append(0xa1, 0x4f)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetWin)
	if err != nil {
		err = msgp.WrapError(err, "BetWin")
		return
	}
	// write "Y"
	err = en.Append(0xa1, 0x59)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinPercent)
	if err != nil {
		err = msgp.WrapError(err, "MinPercent")
		return
	}
	// write "R"
	err = en.Append(0xa1, 0x52)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.FillFactor)
	if err != nil {
		err = msgp.WrapError(err, "FillFactor")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.EventFactor)
	if err != nil {
		err = msgp.WrapError(err, "EventFactor")
		return
	}
	// write "V"
	err = en.Append(0xa1, 0x56)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.VoidFactor)
	if err != nil {
		err = msgp.WrapError(err, "VoidFactor")
		return
	}
	// write "sf"
	err = en.Append(0xa2, 0x73, 0x66)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.StatsFactor)
	if err != nil {
		err = msgp.WrapError(err, "StatsFactor")
		return
	}
	// write "U"
	err = en.Append(0xa1, 0x55)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.ProfitMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "ProfitMultiplier")
		return
	}
	// write "Z"
	err = en.Append(0xa1, 0x5a)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedPrice)
	if err != nil {
		err = msgp.WrapError(err, "WeightedPrice")
		return
	}
	// write "v"
	err = en.Append(0xa1, 0x76)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedVolume)
	if err != nil {
		err = msgp.WrapError(err, "WeightedVolume")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedDistance)
	if err != nil {
		err = msgp.WrapError(err, "WeightedDistance")
		return
	}
	// write "Q"
	err = en.Append(0xa1, 0x51)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.OrderID)
	if err != nil {
		err = msgp.WrapError(err, "OrderID")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Offers)
	if err != nil {
		err = msgp.WrapError(err, "Offers")
		return
	}
	// write "i"
	err = en.Append(0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Index)
	if err != nil {
		err = msgp.WrapError(err, "Index")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.TryBetCount)
	if err != nil {
		err = msgp.WrapError(err, "TryBetCount")
		return
	}
	// write "k"
	err = en.Append(0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.BackupCount)
	if err != nil {
		err = msgp.WrapError(err, "BackupCount")
		return
	}
	// write "P"
	err = en.Append(0xa1, 0x50)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.PriceCount)
	if err != nil {
		err = msgp.WrapError(err, "PriceCount")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Age)
	if err != nil {
		err = msgp.WrapError(err, "Age")
		return
	}
	// write "f"
	err = en.Append(0xa1, 0x66)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsFirst)
	if err != nil {
		err = msgp.WrapError(err, "IsFirst")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	// write "g"
	err = en.Append(0xa1, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsComplete)
	if err != nil {
		err = msgp.WrapError(err, "IsComplete")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Side) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 44
	// string "ca"
	o = append(o, 0xde, 0x0, 0x2c, 0xa2, 0x63, 0x61)
	o = msgp.AppendTime(o, z.CreatedAt)
	// string "l"
	o = append(o, 0xa1, 0x6c)
	o = msgp.AppendTime(o, z.LastData)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.BetName)
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o = msgp.AppendString(o, z.CloseReason)
	// string "os"
	o = append(o, 0xa2, 0x6f, 0x73)
	o = msgp.AppendString(o, z.OrderStatus)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.Bookie)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendString(o, z.MaxReason)
	// string "q"
	o = append(o, 0xa1, 0x71)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PriceList)))
	for za0001 := range z.PriceList {
		o, err = z.PriceList[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001)
			return
		}
	}
	// string "w"
	o = append(o, 0xa1, 0x77)
	o = msgp.AppendFloat64(o, z.MinWin)
	// string "F"
	o = append(o, 0xa1, 0x46)
	o = msgp.AppendFloat64(o, z.FreeBalance)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "M"
	o = append(o, 0xa1, 0x4d)
	o = msgp.AppendFloat64(o, z.CheckMax)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendFloat64(o, z.CheckMin)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendFloat64(o, z.Xrate)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendFloat64(o, z.BackupPrice)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendFloat64(o, z.OrderStake)
	// string "T"
	o = append(o, 0xa1, 0x54)
	o = msgp.AppendFloat64(o, z.OrderPrice)
	// string "S"
	o = append(o, 0xa1, 0x53)
	o = msgp.AppendFloat64(o, z.MinStake)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o = msgp.AppendFloat64(o, z.MaxStake)
	// string "N"
	o = append(o, 0xa1, 0x4e)
	o = msgp.AppendFloat64(o, z.BetPrice)
	// string "j"
	o = append(o, 0xa1, 0x6a)
	o = msgp.AppendFloat64(o, z.BetStake)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendFloat64(o, z.CheckPrice)
	// string "X"
	o = append(o, 0xa1, 0x58)
	o = msgp.AppendFloat64(o, z.MaxPercent)
	// string "W"
	o = append(o, 0xa1, 0x57)
	o = msgp.AppendFloat64(o, z.MaxWin)
	// string "O"
	o = append(o, 0xa1, 0x4f)
	o = msgp.AppendFloat64(o, z.BetWin)
	// string "Y"
	o = append(o, 0xa1, 0x59)
	o = msgp.AppendFloat64(o, z.MinPercent)
	// string "R"
	o = append(o, 0xa1, 0x52)
	o = msgp.AppendFloat64(o, z.FillFactor)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendFloat64(o, z.EventFactor)
	// string "V"
	o = append(o, 0xa1, 0x56)
	o = msgp.AppendFloat64(o, z.VoidFactor)
	// string "sf"
	o = append(o, 0xa2, 0x73, 0x66)
	o = msgp.AppendFloat64(o, z.StatsFactor)
	// string "U"
	o = append(o, 0xa1, 0x55)
	o = msgp.AppendFloat64(o, z.ProfitMultiplier)
	// string "Z"
	o = append(o, 0xa1, 0x5a)
	o = msgp.AppendFloat64(o, z.WeightedPrice)
	// string "v"
	o = append(o, 0xa1, 0x76)
	o = msgp.AppendFloat64(o, z.WeightedVolume)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendFloat64(o, z.WeightedDistance)
	// string "Q"
	o = append(o, 0xa1, 0x51)
	o = msgp.AppendInt32(o, z.OrderID)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt16(o, z.Offers)
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendInt16(o, z.Index)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt16(o, z.TryBetCount)
	// string "k"
	o = append(o, 0xa1, 0x6b)
	o = msgp.AppendInt16(o, z.BackupCount)
	// string "P"
	o = append(o, 0xa1, 0x50)
	o = msgp.AppendInt16(o, z.PriceCount)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendInt16(o, z.Age)
	// string "f"
	o = append(o, 0xa1, 0x66)
	o = msgp.AppendBool(o, z.IsFirst)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendUint8(o, z.UserID)
	// string "g"
	o = append(o, 0xa1, 0x67)
	o = msgp.AppendBool(o, z.IsComplete)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Side) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ca":
			z.CreatedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "l":
			z.LastData, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastData")
				return
			}
		case "n":
			z.BetName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetName")
				return
			}
		case "cr":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "os":
			z.OrderStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderStatus")
				return
			}
		case "b":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "r":
			z.MaxReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxReason")
				return
			}
		case "q":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0002) {
				z.PriceList = (z.PriceList)[:zb0002]
			} else {
				z.PriceList = make([]Price, zb0002)
			}
			for za0001 := range z.PriceList {
				bts, err = z.PriceList[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
			}
		case "w":
			z.MinWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinWin")
				return
			}
		case "F":
			z.FreeBalance, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeBalance")
				return
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "M":
			z.CheckMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckMax")
				return
			}
		case "m":
			z.CheckMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckMin")
				return
			}
		case "x":
			z.Xrate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Xrate")
				return
			}
		case "B":
			z.BackupPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BackupPrice")
				return
			}
		case "s":
			z.OrderStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderStake")
				return
			}
		case "T":
			z.OrderPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderPrice")
				return
			}
		case "S":
			z.MinStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinStake")
				return
			}
		case "h":
			z.MaxStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxStake")
				return
			}
		case "N":
			z.BetPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetPrice")
				return
			}
		case "j":
			z.BetStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetStake")
				return
			}
		case "c":
			z.CheckPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckPrice")
				return
			}
		case "X":
			z.MaxPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPercent")
				return
			}
		case "W":
			z.MaxWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxWin")
				return
			}
		case "O":
			z.BetWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetWin")
				return
			}
		case "Y":
			z.MinPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinPercent")
				return
			}
		case "R":
			z.FillFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FillFactor")
				return
			}
		case "e":
			z.EventFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventFactor")
				return
			}
		case "V":
			z.VoidFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VoidFactor")
				return
			}
		case "sf":
			z.StatsFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsFactor")
				return
			}
		case "U":
			z.ProfitMultiplier, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitMultiplier")
				return
			}
		case "Z":
			z.WeightedPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedPrice")
				return
			}
		case "v":
			z.WeightedVolume, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedVolume")
				return
			}
		case "d":
			z.WeightedDistance, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedDistance")
				return
			}
		case "Q":
			z.OrderID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "o":
			z.Offers, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offers")
				return
			}
		case "i":
			z.Index, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "t":
			z.TryBetCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TryBetCount")
				return
			}
		case "k":
			z.BackupCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BackupCount")
				return
			}
		case "P":
			z.PriceCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceCount")
				return
			}
		case "a":
			z.Age, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "f":
			z.IsFirst, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsFirst")
				return
			}
		case "u":
			z.UserID, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "g":
			z.IsComplete, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsComplete")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Side) Msgsize() (s int) {
	s = 3 + 3 + msgp.TimeSize + 2 + msgp.TimeSize + 2 + msgp.StringPrefixSize + len(z.BetName) + 3 + msgp.StringPrefixSize + len(z.CloseReason) + 3 + msgp.StringPrefixSize + len(z.OrderStatus) + 2 + msgp.StringPrefixSize + len(z.Bookie) + 2 + msgp.StringPrefixSize + len(z.MaxReason) + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.PriceList {
		s += z.PriceList[za0001].Msgsize()
	}
	s += 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 3 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int32Size + 2 + msgp.Int16Size + 2 + msgp.Int16Size + 2 + msgp.Int16Size + 2 + msgp.Int16Size + 2 + msgp.Int16Size + 2 + msgp.Int16Size + 2 + msgp.BoolSize + 2 + msgp.Uint8Size + 2 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SurebetDB) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "EventStarts":
			z.EventStarts, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "EventStarts")
				return
			}
		case "Key":
			z.Key, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "CalcFirstReason":
			z.CalcFirstReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstReason")
				return
			}
		case "EventSport":
			z.EventSport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventSport")
				return
			}
		case "EventString":
			z.EventString, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventString")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if zb0002 != uint32(2) {
				err = msgp.ArrayError{Wanted: uint32(2), Got: zb0002}
				return
			}
			for za0001 := range z.Members {
				err = z.Members[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		case "Timing":
			err = z.Timing.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Timing")
				return
			}
		case "CalcLastDataTs":
			z.CalcLastDataTs, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "CalcLastDataTs")
				return
			}
		case "CalcProfit":
			z.CalcProfit, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcProfit")
				return
			}
		case "CalcGross":
			z.CalcGross, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcGross")
				return
			}
		case "CalcWinDiffPercent":
			z.CalcWinDiffPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcWinDiffPercent")
				return
			}
		case "Spread":
			z.Spread, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Spread")
				return
			}
		case "ID":
			z.ID, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "EventID":
			z.EventID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "StatsAmountLine":
			z.StatsAmountLine, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountLine")
				return
			}
		case "StatsAmountEvent":
			z.StatsAmountEvent, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountEvent")
				return
			}
		case "CalcLeftBackupProfit":
			z.CalcLeftBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcLeftBackupProfit")
				return
			}
		case "CalcHigherWinIndex":
			z.CalcHigherWinIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcHigherWinIndex")
				return
			}
		case "CalcLowerWinIndex":
			z.CalcLowerWinIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcLowerWinIndex")
				return
			}
		case "CalcRightBackupProfit":
			z.CalcRightBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcRightBackupProfit")
				return
			}
		case "CalcBackupProfit":
			z.CalcBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcBackupProfit")
				return
			}
		case "IntervalCount":
			z.IntervalCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "IntervalCount")
				return
			}
		case "StatsCountEvent":
			z.StatsCountEvent, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "StatsCountEvent")
				return
			}
		case "StatsCountLine":
			z.StatsCountLine, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "StatsCountLine")
				return
			}
		case "CalcSecondIndex":
			z.CalcSecondIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcSecondIndex")
				return
			}
		case "CalcFirstIndex":
			z.CalcFirstIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstIndex")
				return
			}
		case "Volume":
			z.Volume, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
		case "CalcBeforeEvent":
			z.CalcBeforeEvent, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcBeforeEvent")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SurebetDB) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 28
	// write "EventStarts"
	err = en.Append(0xde, 0x0, 0x1c, 0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteTime(z.EventStarts)
	if err != nil {
		err = msgp.WrapError(err, "EventStarts")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "CalcFirstReason"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CalcFirstReason)
	if err != nil {
		err = msgp.WrapError(err, "CalcFirstReason")
		return
	}
	// write "EventSport"
	err = en.Append(0xaa, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventSport)
	if err != nil {
		err = msgp.WrapError(err, "EventSport")
		return
	}
	// write "EventString"
	err = en.Append(0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventString)
	if err != nil {
		err = msgp.WrapError(err, "EventString")
		return
	}
	// write "Members"
	err = en.Append(0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(2))
	if err != nil {
		err = msgp.WrapError(err, "Members")
		return
	}
	for za0001 := range z.Members {
		err = z.Members[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001)
			return
		}
	}
	// write "Timing"
	err = en.Append(0xa6, 0x54, 0x69, 0x6d, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = z.Timing.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Timing")
		return
	}
	// write "CalcLastDataTs"
	err = en.Append(0xae, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.CalcLastDataTs)
	if err != nil {
		err = msgp.WrapError(err, "CalcLastDataTs")
		return
	}
	// write "CalcProfit"
	err = en.Append(0xaa, 0x43, 0x61, 0x6c, 0x63, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcProfit")
		return
	}
	// write "CalcGross"
	err = en.Append(0xa9, 0x43, 0x61, 0x6c, 0x63, 0x47, 0x72, 0x6f, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcGross)
	if err != nil {
		err = msgp.WrapError(err, "CalcGross")
		return
	}
	// write "CalcWinDiffPercent"
	err = en.Append(0xb2, 0x43, 0x61, 0x6c, 0x63, 0x57, 0x69, 0x6e, 0x44, 0x69, 0x66, 0x66, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcWinDiffPercent)
	if err != nil {
		err = msgp.WrapError(err, "CalcWinDiffPercent")
		return
	}
	// write "Spread"
	err = en.Append(0xa6, 0x53, 0x70, 0x72, 0x65, 0x61, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Spread)
	if err != nil {
		err = msgp.WrapError(err, "Spread")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "EventID"
	err = en.Append(0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.EventID)
	if err != nil {
		err = msgp.WrapError(err, "EventID")
		return
	}
	// write "StatsAmountLine"
	err = en.Append(0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.StatsAmountLine)
	if err != nil {
		err = msgp.WrapError(err, "StatsAmountLine")
		return
	}
	// write "StatsAmountEvent"
	err = en.Append(0xb0, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.StatsAmountEvent)
	if err != nil {
		err = msgp.WrapError(err, "StatsAmountEvent")
		return
	}
	// write "CalcLeftBackupProfit"
	err = en.Append(0xb4, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x65, 0x66, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcLeftBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcLeftBackupProfit")
		return
	}
	// write "CalcHigherWinIndex"
	err = en.Append(0xb2, 0x43, 0x61, 0x6c, 0x63, 0x48, 0x69, 0x67, 0x68, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcHigherWinIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcHigherWinIndex")
		return
	}
	// write "CalcLowerWinIndex"
	err = en.Append(0xb1, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x6f, 0x77, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcLowerWinIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcLowerWinIndex")
		return
	}
	// write "CalcRightBackupProfit"
	err = en.Append(0xb5, 0x43, 0x61, 0x6c, 0x63, 0x52, 0x69, 0x67, 0x68, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcRightBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcRightBackupProfit")
		return
	}
	// write "CalcBackupProfit"
	err = en.Append(0xb0, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcBackupProfit")
		return
	}
	// write "IntervalCount"
	err = en.Append(0xad, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.IntervalCount)
	if err != nil {
		err = msgp.WrapError(err, "IntervalCount")
		return
	}
	// write "StatsCountEvent"
	err = en.Append(0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.StatsCountEvent)
	if err != nil {
		err = msgp.WrapError(err, "StatsCountEvent")
		return
	}
	// write "StatsCountLine"
	err = en.Append(0xae, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.StatsCountLine)
	if err != nil {
		err = msgp.WrapError(err, "StatsCountLine")
		return
	}
	// write "CalcSecondIndex"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcSecondIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcSecondIndex")
		return
	}
	// write "CalcFirstIndex"
	err = en.Append(0xae, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcFirstIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcFirstIndex")
		return
	}
	// write "Volume"
	err = en.Append(0xa6, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Volume)
	if err != nil {
		err = msgp.WrapError(err, "Volume")
		return
	}
	// write "CalcBeforeEvent"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcBeforeEvent)
	if err != nil {
		err = msgp.WrapError(err, "CalcBeforeEvent")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SurebetDB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 28
	// string "EventStarts"
	o = append(o, 0xde, 0x0, 0x1c, 0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendTime(o, z.EventStarts)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.Key)
	// string "CalcFirstReason"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.CalcFirstReason)
	// string "EventSport"
	o = append(o, 0xaa, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.EventSport)
	// string "EventString"
	o = append(o, 0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	o = msgp.AppendString(o, z.EventString)
	// string "Members"
	o = append(o, 0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(2))
	for za0001 := range z.Members {
		o, err = z.Members[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001)
			return
		}
	}
	// string "Timing"
	o = append(o, 0xa6, 0x54, 0x69, 0x6d, 0x69, 0x6e, 0x67)
	o, err = z.Timing.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timing")
		return
	}
	// string "CalcLastDataTs"
	o = append(o, 0xae, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x54, 0x73)
	o = msgp.AppendInt64(o, z.CalcLastDataTs)
	// string "CalcProfit"
	o = append(o, 0xaa, 0x43, 0x61, 0x6c, 0x63, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendFloat64(o, z.CalcProfit)
	// string "CalcGross"
	o = append(o, 0xa9, 0x43, 0x61, 0x6c, 0x63, 0x47, 0x72, 0x6f, 0x73, 0x73)
	o = msgp.AppendFloat64(o, z.CalcGross)
	// string "CalcWinDiffPercent"
	o = append(o, 0xb2, 0x43, 0x61, 0x6c, 0x63, 0x57, 0x69, 0x6e, 0x44, 0x69, 0x66, 0x66, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.CalcWinDiffPercent)
	// string "Spread"
	o = append(o, 0xa6, 0x53, 0x70, 0x72, 0x65, 0x61, 0x64)
	o = msgp.AppendFloat64(o, z.Spread)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt64(o, z.ID)
	// string "EventID"
	o = append(o, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44)
	o = msgp.AppendInt32(o, z.EventID)
	// string "StatsAmountLine"
	o = append(o, 0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendInt32(o, z.StatsAmountLine)
	// string "StatsAmountEvent"
	o = append(o, 0xb0, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt32(o, z.StatsAmountEvent)
	// string "CalcLeftBackupProfit"
	o = append(o, 0xb4, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x65, 0x66, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcLeftBackupProfit)
	// string "CalcHigherWinIndex"
	o = append(o, 0xb2, 0x43, 0x61, 0x6c, 0x63, 0x48, 0x69, 0x67, 0x68, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcHigherWinIndex)
	// string "CalcLowerWinIndex"
	o = append(o, 0xb1, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x6f, 0x77, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcLowerWinIndex)
	// string "CalcRightBackupProfit"
	o = append(o, 0xb5, 0x43, 0x61, 0x6c, 0x63, 0x52, 0x69, 0x67, 0x68, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcRightBackupProfit)
	// string "CalcBackupProfit"
	o = append(o, 0xb0, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcBackupProfit)
	// string "IntervalCount"
	o = append(o, 0xad, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.IntervalCount)
	// string "StatsCountEvent"
	o = append(o, 0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.StatsCountEvent)
	// string "StatsCountLine"
	o = append(o, 0xae, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendInt16(o, z.StatsCountLine)
	// string "CalcSecondIndex"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcSecondIndex)
	// string "CalcFirstIndex"
	o = append(o, 0xae, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcFirstIndex)
	// string "Volume"
	o = append(o, 0xa6, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	o = msgp.AppendInt16(o, z.Volume)
	// string "CalcBeforeEvent"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.CalcBeforeEvent)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SurebetDB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "EventStarts":
			z.EventStarts, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventStarts")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "CalcFirstReason":
			z.CalcFirstReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstReason")
				return
			}
		case "EventSport":
			z.EventSport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventSport")
				return
			}
		case "EventString":
			z.EventString, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventString")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if zb0002 != uint32(2) {
				err = msgp.ArrayError{Wanted: uint32(2), Got: zb0002}
				return
			}
			for za0001 := range z.Members {
				bts, err = z.Members[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		case "Timing":
			bts, err = z.Timing.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timing")
				return
			}
		case "CalcLastDataTs":
			z.CalcLastDataTs, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLastDataTs")
				return
			}
		case "CalcProfit":
			z.CalcProfit, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcProfit")
				return
			}
		case "CalcGross":
			z.CalcGross, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcGross")
				return
			}
		case "CalcWinDiffPercent":
			z.CalcWinDiffPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcWinDiffPercent")
				return
			}
		case "Spread":
			z.Spread, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spread")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "EventID":
			z.EventID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "StatsAmountLine":
			z.StatsAmountLine, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountLine")
				return
			}
		case "StatsAmountEvent":
			z.StatsAmountEvent, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountEvent")
				return
			}
		case "CalcLeftBackupProfit":
			z.CalcLeftBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLeftBackupProfit")
				return
			}
		case "CalcHigherWinIndex":
			z.CalcHigherWinIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcHigherWinIndex")
				return
			}
		case "CalcLowerWinIndex":
			z.CalcLowerWinIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLowerWinIndex")
				return
			}
		case "CalcRightBackupProfit":
			z.CalcRightBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcRightBackupProfit")
				return
			}
		case "CalcBackupProfit":
			z.CalcBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcBackupProfit")
				return
			}
		case "IntervalCount":
			z.IntervalCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IntervalCount")
				return
			}
		case "StatsCountEvent":
			z.StatsCountEvent, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsCountEvent")
				return
			}
		case "StatsCountLine":
			z.StatsCountLine, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsCountLine")
				return
			}
		case "CalcSecondIndex":
			z.CalcSecondIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcSecondIndex")
				return
			}
		case "CalcFirstIndex":
			z.CalcFirstIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstIndex")
				return
			}
		case "Volume":
			z.Volume, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
		case "CalcBeforeEvent":
			z.CalcBeforeEvent, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcBeforeEvent")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SurebetDB) Msgsize() (s int) {
	s = 3 + 12 + msgp.TimeSize + 4 + msgp.StringPrefixSize + len(z.Key) + 16 + msgp.StringPrefixSize + len(z.CalcFirstReason) + 11 + msgp.StringPrefixSize + len(z.EventSport) + 12 + msgp.StringPrefixSize + len(z.EventString) + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Members {
		s += z.Members[za0001].Msgsize()
	}
	s += 7 + z.Timing.Msgsize() + 15 + msgp.Int64Size + 11 + msgp.Float64Size + 10 + msgp.Float64Size + 19 + msgp.Float64Size + 7 + msgp.Float64Size + 3 + msgp.Int64Size + 8 + msgp.Int32Size + 16 + msgp.Int32Size + 17 + msgp.Int32Size + 21 + msgp.Int16Size + 19 + msgp.Int16Size + 18 + msgp.Int16Size + 22 + msgp.Int16Size + 17 + msgp.Int16Size + 14 + msgp.Int16Size + 16 + msgp.Int16Size + 15 + msgp.Int16Size + 16 + msgp.Int16Size + 15 + msgp.Int16Size + 7 + msgp.Int16Size + 16 + msgp.Int16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Timing) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			z.WsReceive, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "p":
			z.BeginProcess, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginProcess")
				return
			}
		case "u":
			z.BeginSubmit, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginSubmit")
				return
			}
		case "j":
			z.BeginJob, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginJob")
				return
			}
		case "o":
			z.BeginOpen, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginOpen")
				return
			}
		case "e":
			z.EndOpen, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndOpen")
				return
			}
		case "s":
			z.BeginCheck, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginCheck")
				return
			}
		case "t":
			z.BeginStats, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginStats")
				return
			}
		case "a":
			z.EndStats, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndStats")
				return
			}
		case "c":
			z.FirstComplete, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FirstComplete")
				return
			}
		case "k":
			z.ConditionsOk, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ConditionsOk")
				return
			}
		case "b":
			z.BeginFirstBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginFirstBet")
				return
			}
		case "n":
			z.EndFirstBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndFirstBet")
				return
			}
		case "f":
			z.BeginCalcSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginCalcSecondBet")
				return
			}
		case "d":
			z.BeginSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginSecondBet")
				return
			}
		case "m":
			z.EndSecondBet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndSecondBet")
				return
			}
		case "x":
			z.BeginExit, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BeginExit")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Timing) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 17
	// write "r"
	err = en.Append(0xde, 0x0, 0x11, 0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.WsReceive)
	if err != nil {
		err = msgp.WrapError(err, "WsReceive")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginProcess)
	if err != nil {
		err = msgp.WrapError(err, "BeginProcess")
		return
	}
	// write "u"
	err = en.Append(0xa1, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginSubmit)
	if err != nil {
		err = msgp.WrapError(err, "BeginSubmit")
		return
	}
	// write "j"
	err = en.Append(0xa1, 0x6a)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginJob)
	if err != nil {
		err = msgp.WrapError(err, "BeginJob")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginOpen)
	if err != nil {
		err = msgp.WrapError(err, "BeginOpen")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndOpen)
	if err != nil {
		err = msgp.WrapError(err, "EndOpen")
		return
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginCheck)
	if err != nil {
		err = msgp.WrapError(err, "BeginCheck")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginStats)
	if err != nil {
		err = msgp.WrapError(err, "BeginStats")
		return
	}
	// write "a"
	err = en.Append(0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndStats)
	if err != nil {
		err = msgp.WrapError(err, "EndStats")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.FirstComplete)
	if err != nil {
		err = msgp.WrapError(err, "FirstComplete")
		return
	}
	// write "k"
	err = en.Append(0xa1, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ConditionsOk)
	if err != nil {
		err = msgp.WrapError(err, "ConditionsOk")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginFirstBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginFirstBet")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndFirstBet)
	if err != nil {
		err = msgp.WrapError(err, "EndFirstBet")
		return
	}
	// write "f"
	err = en.Append(0xa1, 0x66)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginCalcSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginCalcSecondBet")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "BeginSecondBet")
		return
	}
	// write "m"
	err = en.Append(0xa1, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndSecondBet)
	if err != nil {
		err = msgp.WrapError(err, "EndSecondBet")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BeginExit)
	if err != nil {
		err = msgp.WrapError(err, "BeginExit")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Timing) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "r"
	o = append(o, 0xde, 0x0, 0x11, 0xa1, 0x72)
	o = msgp.AppendInt64(o, z.WsReceive)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendInt64(o, z.BeginProcess)
	// string "u"
	o = append(o, 0xa1, 0x75)
	o = msgp.AppendInt64(o, z.BeginSubmit)
	// string "j"
	o = append(o, 0xa1, 0x6a)
	o = msgp.AppendInt64(o, z.BeginJob)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt64(o, z.BeginOpen)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendInt64(o, z.EndOpen)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendInt64(o, z.BeginCheck)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.BeginStats)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.EndStats)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendInt64(o, z.FirstComplete)
	// string "k"
	o = append(o, 0xa1, 0x6b)
	o = msgp.AppendInt64(o, z.ConditionsOk)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendInt64(o, z.BeginFirstBet)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendInt64(o, z.EndFirstBet)
	// string "f"
	o = append(o, 0xa1, 0x66)
	o = msgp.AppendInt64(o, z.BeginCalcSecondBet)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt64(o, z.BeginSecondBet)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o = msgp.AppendInt64(o, z.EndSecondBet)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendInt64(o, z.BeginExit)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Timing) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "r":
			z.WsReceive, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WsReceive")
				return
			}
		case "p":
			z.BeginProcess, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginProcess")
				return
			}
		case "u":
			z.BeginSubmit, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginSubmit")
				return
			}
		case "j":
			z.BeginJob, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginJob")
				return
			}
		case "o":
			z.BeginOpen, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginOpen")
				return
			}
		case "e":
			z.EndOpen, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndOpen")
				return
			}
		case "s":
			z.BeginCheck, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginCheck")
				return
			}
		case "t":
			z.BeginStats, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginStats")
				return
			}
		case "a":
			z.EndStats, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndStats")
				return
			}
		case "c":
			z.FirstComplete, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FirstComplete")
				return
			}
		case "k":
			z.ConditionsOk, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConditionsOk")
				return
			}
		case "b":
			z.BeginFirstBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginFirstBet")
				return
			}
		case "n":
			z.EndFirstBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndFirstBet")
				return
			}
		case "f":
			z.BeginCalcSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginCalcSecondBet")
				return
			}
		case "d":
			z.BeginSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginSecondBet")
				return
			}
		case "m":
			z.EndSecondBet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndSecondBet")
				return
			}
		case "x":
			z.BeginExit, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BeginExit")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Timing) Msgsize() (s int) {
	s = 3 + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}
