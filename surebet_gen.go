package tbmodels

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Price) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Bookie":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "Price":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Min":
			z.Min, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "Max":
			z.Max, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		case "TS":
			z.TS, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "IsBest":
			z.IsBest, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsBest")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Price) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "Bookie"
	err = en.Append(0x86, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "Price"
	err = en.Append(0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "Min"
	err = en.Append(0xa3, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Min)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	// write "Max"
	err = en.Append(0xa3, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Max)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	// write "TS"
	err = en.Append(0xa2, 0x54, 0x53)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TS)
	if err != nil {
		err = msgp.WrapError(err, "TS")
		return
	}
	// write "IsBest"
	err = en.Append(0xa6, 0x49, 0x73, 0x42, 0x65, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsBest)
	if err != nil {
		err = msgp.WrapError(err, "IsBest")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Price) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "Bookie"
	o = append(o, 0x86, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	o = msgp.AppendString(o, z.Bookie)
	// string "Price"
	o = append(o, 0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.Price)
	// string "Min"
	o = append(o, 0xa3, 0x4d, 0x69, 0x6e)
	o = msgp.AppendFloat64(o, z.Min)
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o = msgp.AppendFloat64(o, z.Max)
	// string "TS"
	o = append(o, 0xa2, 0x54, 0x53)
	o = msgp.AppendInt64(o, z.TS)
	// string "IsBest"
	o = append(o, 0xa6, 0x49, 0x73, 0x42, 0x65, 0x73, 0x74)
	o = msgp.AppendBool(o, z.IsBest)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Price) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Bookie":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "Price":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Min":
			z.Min, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "Max":
			z.Max, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		case "TS":
			z.TS, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TS")
				return
			}
		case "IsBest":
			z.IsBest, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsBest")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Price) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Bookie) + 6 + msgp.Float64Size + 4 + msgp.Float64Size + 4 + msgp.Float64Size + 3 + msgp.Int64Size + 7 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Side) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Index":
			z.Index, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "BetName":
			z.BetName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BetName")
				return
			}
		case "Price":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Xrate":
			z.Xrate, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Xrate")
				return
			}
		case "UserID":
			z.UserID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "Bookie":
			z.Bookie, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "CheckPrice":
			z.CheckPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckPrice")
				return
			}
		case "CheckMin":
			z.CheckMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckMin")
				return
			}
		case "CheckMax":
			z.CheckMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CheckMax")
				return
			}
		case "Offers":
			z.Offers, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Offers")
				return
			}
		case "IsComplete":
			z.IsComplete, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsComplete")
				return
			}
		case "CreatedAt":
			z.CreatedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "LastData":
			z.LastData, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastData")
				return
			}
		case "Age":
			z.Age, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "BackupPrice":
			z.BackupPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BackupPrice")
				return
			}
		case "PriceCount":
			z.PriceCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "PriceCount")
				return
			}
		case "BackupCount":
			z.BackupCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "BackupCount")
				return
			}
		case "MinStake":
			z.MinStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinStake")
				return
			}
		case "MaxStake":
			z.MaxStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxStake")
				return
			}
		case "BetPrice":
			z.BetPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetPrice")
				return
			}
		case "BetStake":
			z.BetStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetStake")
				return
			}
		case "IsFirst":
			z.IsFirst, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsFirst")
				return
			}
		case "MinWin":
			z.MinWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinWin")
				return
			}
		case "MaxWin":
			z.MaxWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxWin")
				return
			}
		case "BetWin":
			z.BetWin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BetWin")
				return
			}
		case "FreeBalance":
			z.FreeBalance, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "FreeBalance")
				return
			}
		case "FillFactor":
			z.FillFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "FillFactor")
				return
			}
		case "EventFactor":
			z.EventFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "EventFactor")
				return
			}
		case "VoidFactor":
			z.VoidFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "VoidFactor")
				return
			}
		case "StatsFactor":
			z.StatsFactor, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "StatsFactor")
				return
			}
		case "ProfitMultiplier":
			z.ProfitMultiplier, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ProfitMultiplier")
				return
			}
		case "WeightedPrice":
			z.WeightedPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedPrice")
				return
			}
		case "WeightedVolume":
			z.WeightedVolume, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedVolume")
				return
			}
		case "WeightedDistance":
			z.WeightedDistance, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WeightedDistance")
				return
			}
		case "MinPercent":
			z.MinPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinPercent")
				return
			}
		case "MaxPercent":
			z.MaxPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPercent")
				return
			}
		case "MaxReason":
			z.MaxReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MaxReason")
				return
			}
		case "OrderID":
			z.OrderID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "TryBetCount":
			z.TryBetCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "TryBetCount")
				return
			}
		case "OrderPrice":
			z.OrderPrice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderPrice")
				return
			}
		case "OrderStake":
			z.OrderStake, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderStake")
				return
			}
		case "OrderStatus":
			z.OrderStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderStatus")
				return
			}
		case "CloseReason":
			z.CloseReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "PriceList":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0002) {
				z.PriceList = (z.PriceList)[:zb0002]
			} else {
				z.PriceList = make([]Price, zb0002)
			}
			for za0001 := range z.PriceList {
				err = z.PriceList[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Side) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 44
	// write "Index"
	err = en.Append(0xde, 0x0, 0x2c, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Index)
	if err != nil {
		err = msgp.WrapError(err, "Index")
		return
	}
	// write "BetName"
	err = en.Append(0xa7, 0x42, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BetName)
	if err != nil {
		err = msgp.WrapError(err, "BetName")
		return
	}
	// write "Price"
	err = en.Append(0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "Xrate"
	err = en.Append(0xa5, 0x58, 0x72, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Xrate)
	if err != nil {
		err = msgp.WrapError(err, "Xrate")
		return
	}
	// write "UserID"
	err = en.Append(0xa6, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	// write "Bookie"
	err = en.Append(0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bookie)
	if err != nil {
		err = msgp.WrapError(err, "Bookie")
		return
	}
	// write "CheckPrice"
	err = en.Append(0xaa, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckPrice)
	if err != nil {
		err = msgp.WrapError(err, "CheckPrice")
		return
	}
	// write "CheckMin"
	err = en.Append(0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckMin)
	if err != nil {
		err = msgp.WrapError(err, "CheckMin")
		return
	}
	// write "CheckMax"
	err = en.Append(0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CheckMax)
	if err != nil {
		err = msgp.WrapError(err, "CheckMax")
		return
	}
	// write "Offers"
	err = en.Append(0xa6, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Offers)
	if err != nil {
		err = msgp.WrapError(err, "Offers")
		return
	}
	// write "IsComplete"
	err = en.Append(0xaa, 0x49, 0x73, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsComplete)
	if err != nil {
		err = msgp.WrapError(err, "IsComplete")
		return
	}
	// write "CreatedAt"
	err = en.Append(0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CreatedAt)
	if err != nil {
		err = msgp.WrapError(err, "CreatedAt")
		return
	}
	// write "LastData"
	err = en.Append(0xa8, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastData)
	if err != nil {
		err = msgp.WrapError(err, "LastData")
		return
	}
	// write "Age"
	err = en.Append(0xa3, 0x41, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Age)
	if err != nil {
		err = msgp.WrapError(err, "Age")
		return
	}
	// write "BackupPrice"
	err = en.Append(0xab, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BackupPrice)
	if err != nil {
		err = msgp.WrapError(err, "BackupPrice")
		return
	}
	// write "PriceCount"
	err = en.Append(0xaa, 0x50, 0x72, 0x69, 0x63, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.PriceCount)
	if err != nil {
		err = msgp.WrapError(err, "PriceCount")
		return
	}
	// write "BackupCount"
	err = en.Append(0xab, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.BackupCount)
	if err != nil {
		err = msgp.WrapError(err, "BackupCount")
		return
	}
	// write "MinStake"
	err = en.Append(0xa8, 0x4d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinStake)
	if err != nil {
		err = msgp.WrapError(err, "MinStake")
		return
	}
	// write "MaxStake"
	err = en.Append(0xa8, 0x4d, 0x61, 0x78, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxStake)
	if err != nil {
		err = msgp.WrapError(err, "MaxStake")
		return
	}
	// write "BetPrice"
	err = en.Append(0xa8, 0x42, 0x65, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetPrice)
	if err != nil {
		err = msgp.WrapError(err, "BetPrice")
		return
	}
	// write "BetStake"
	err = en.Append(0xa8, 0x42, 0x65, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetStake)
	if err != nil {
		err = msgp.WrapError(err, "BetStake")
		return
	}
	// write "IsFirst"
	err = en.Append(0xa7, 0x49, 0x73, 0x46, 0x69, 0x72, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsFirst)
	if err != nil {
		err = msgp.WrapError(err, "IsFirst")
		return
	}
	// write "MinWin"
	err = en.Append(0xa6, 0x4d, 0x69, 0x6e, 0x57, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinWin)
	if err != nil {
		err = msgp.WrapError(err, "MinWin")
		return
	}
	// write "MaxWin"
	err = en.Append(0xa6, 0x4d, 0x61, 0x78, 0x57, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxWin)
	if err != nil {
		err = msgp.WrapError(err, "MaxWin")
		return
	}
	// write "BetWin"
	err = en.Append(0xa6, 0x42, 0x65, 0x74, 0x57, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BetWin)
	if err != nil {
		err = msgp.WrapError(err, "BetWin")
		return
	}
	// write "FreeBalance"
	err = en.Append(0xab, 0x46, 0x72, 0x65, 0x65, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.FreeBalance)
	if err != nil {
		err = msgp.WrapError(err, "FreeBalance")
		return
	}
	// write "FillFactor"
	err = en.Append(0xaa, 0x46, 0x69, 0x6c, 0x6c, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.FillFactor)
	if err != nil {
		err = msgp.WrapError(err, "FillFactor")
		return
	}
	// write "EventFactor"
	err = en.Append(0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.EventFactor)
	if err != nil {
		err = msgp.WrapError(err, "EventFactor")
		return
	}
	// write "VoidFactor"
	err = en.Append(0xaa, 0x56, 0x6f, 0x69, 0x64, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.VoidFactor)
	if err != nil {
		err = msgp.WrapError(err, "VoidFactor")
		return
	}
	// write "StatsFactor"
	err = en.Append(0xab, 0x53, 0x74, 0x61, 0x74, 0x73, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.StatsFactor)
	if err != nil {
		err = msgp.WrapError(err, "StatsFactor")
		return
	}
	// write "ProfitMultiplier"
	err = en.Append(0xb0, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.ProfitMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "ProfitMultiplier")
		return
	}
	// write "WeightedPrice"
	err = en.Append(0xad, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedPrice)
	if err != nil {
		err = msgp.WrapError(err, "WeightedPrice")
		return
	}
	// write "WeightedVolume"
	err = en.Append(0xae, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedVolume)
	if err != nil {
		err = msgp.WrapError(err, "WeightedVolume")
		return
	}
	// write "WeightedDistance"
	err = en.Append(0xb0, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.WeightedDistance)
	if err != nil {
		err = msgp.WrapError(err, "WeightedDistance")
		return
	}
	// write "MinPercent"
	err = en.Append(0xaa, 0x4d, 0x69, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MinPercent)
	if err != nil {
		err = msgp.WrapError(err, "MinPercent")
		return
	}
	// write "MaxPercent"
	err = en.Append(0xaa, 0x4d, 0x61, 0x78, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.MaxPercent)
	if err != nil {
		err = msgp.WrapError(err, "MaxPercent")
		return
	}
	// write "MaxReason"
	err = en.Append(0xa9, 0x4d, 0x61, 0x78, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.MaxReason)
	if err != nil {
		err = msgp.WrapError(err, "MaxReason")
		return
	}
	// write "OrderID"
	err = en.Append(0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.OrderID)
	if err != nil {
		err = msgp.WrapError(err, "OrderID")
		return
	}
	// write "TryBetCount"
	err = en.Append(0xab, 0x54, 0x72, 0x79, 0x42, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.TryBetCount)
	if err != nil {
		err = msgp.WrapError(err, "TryBetCount")
		return
	}
	// write "OrderPrice"
	err = en.Append(0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x50, 0x72, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderPrice)
	if err != nil {
		err = msgp.WrapError(err, "OrderPrice")
		return
	}
	// write "OrderStake"
	err = en.Append(0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x6b, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderStake)
	if err != nil {
		err = msgp.WrapError(err, "OrderStake")
		return
	}
	// write "OrderStatus"
	err = en.Append(0xab, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderStatus)
	if err != nil {
		err = msgp.WrapError(err, "OrderStatus")
		return
	}
	// write "CloseReason"
	err = en.Append(0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CloseReason)
	if err != nil {
		err = msgp.WrapError(err, "CloseReason")
		return
	}
	// write "PriceList"
	err = en.Append(0xa9, 0x50, 0x72, 0x69, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PriceList)))
	if err != nil {
		err = msgp.WrapError(err, "PriceList")
		return
	}
	for za0001 := range z.PriceList {
		err = z.PriceList[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Side) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 44
	// string "Index"
	o = append(o, 0xde, 0x0, 0x2c, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.Index)
	// string "BetName"
	o = append(o, 0xa7, 0x42, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.BetName)
	// string "Price"
	o = append(o, 0xa5, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.Price)
	// string "Xrate"
	o = append(o, 0xa5, 0x58, 0x72, 0x61, 0x74, 0x65)
	o = msgp.AppendFloat64(o, z.Xrate)
	// string "UserID"
	o = append(o, 0xa6, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendUint8(o, z.UserID)
	// string "Bookie"
	o = append(o, 0xa6, 0x42, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	o = msgp.AppendString(o, z.Bookie)
	// string "CheckPrice"
	o = append(o, 0xaa, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.CheckPrice)
	// string "CheckMin"
	o = append(o, 0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x4d, 0x69, 0x6e)
	o = msgp.AppendFloat64(o, z.CheckMin)
	// string "CheckMax"
	o = append(o, 0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x4d, 0x61, 0x78)
	o = msgp.AppendFloat64(o, z.CheckMax)
	// string "Offers"
	o = append(o, 0xa6, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73)
	o = msgp.AppendInt16(o, z.Offers)
	// string "IsComplete"
	o = append(o, 0xaa, 0x49, 0x73, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
	o = msgp.AppendBool(o, z.IsComplete)
	// string "CreatedAt"
	o = append(o, 0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
	o = msgp.AppendTime(o, z.CreatedAt)
	// string "LastData"
	o = append(o, 0xa8, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendTime(o, z.LastData)
	// string "Age"
	o = append(o, 0xa3, 0x41, 0x67, 0x65)
	o = msgp.AppendInt16(o, z.Age)
	// string "BackupPrice"
	o = append(o, 0xab, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.BackupPrice)
	// string "PriceCount"
	o = append(o, 0xaa, 0x50, 0x72, 0x69, 0x63, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.PriceCount)
	// string "BackupCount"
	o = append(o, 0xab, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.BackupCount)
	// string "MinStake"
	o = append(o, 0xa8, 0x4d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendFloat64(o, z.MinStake)
	// string "MaxStake"
	o = append(o, 0xa8, 0x4d, 0x61, 0x78, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendFloat64(o, z.MaxStake)
	// string "BetPrice"
	o = append(o, 0xa8, 0x42, 0x65, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.BetPrice)
	// string "BetStake"
	o = append(o, 0xa8, 0x42, 0x65, 0x74, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendFloat64(o, z.BetStake)
	// string "IsFirst"
	o = append(o, 0xa7, 0x49, 0x73, 0x46, 0x69, 0x72, 0x73, 0x74)
	o = msgp.AppendBool(o, z.IsFirst)
	// string "MinWin"
	o = append(o, 0xa6, 0x4d, 0x69, 0x6e, 0x57, 0x69, 0x6e)
	o = msgp.AppendFloat64(o, z.MinWin)
	// string "MaxWin"
	o = append(o, 0xa6, 0x4d, 0x61, 0x78, 0x57, 0x69, 0x6e)
	o = msgp.AppendFloat64(o, z.MaxWin)
	// string "BetWin"
	o = append(o, 0xa6, 0x42, 0x65, 0x74, 0x57, 0x69, 0x6e)
	o = msgp.AppendFloat64(o, z.BetWin)
	// string "FreeBalance"
	o = append(o, 0xab, 0x46, 0x72, 0x65, 0x65, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.FreeBalance)
	// string "FillFactor"
	o = append(o, 0xaa, 0x46, 0x69, 0x6c, 0x6c, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendFloat64(o, z.FillFactor)
	// string "EventFactor"
	o = append(o, 0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendFloat64(o, z.EventFactor)
	// string "VoidFactor"
	o = append(o, 0xaa, 0x56, 0x6f, 0x69, 0x64, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendFloat64(o, z.VoidFactor)
	// string "StatsFactor"
	o = append(o, 0xab, 0x53, 0x74, 0x61, 0x74, 0x73, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendFloat64(o, z.StatsFactor)
	// string "ProfitMultiplier"
	o = append(o, 0xb0, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendFloat64(o, z.ProfitMultiplier)
	// string "WeightedPrice"
	o = append(o, 0xad, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.WeightedPrice)
	// string "WeightedVolume"
	o = append(o, 0xae, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	o = msgp.AppendFloat64(o, z.WeightedVolume)
	// string "WeightedDistance"
	o = append(o, 0xb0, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.WeightedDistance)
	// string "MinPercent"
	o = append(o, 0xaa, 0x4d, 0x69, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.MinPercent)
	// string "MaxPercent"
	o = append(o, 0xaa, 0x4d, 0x61, 0x78, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.MaxPercent)
	// string "MaxReason"
	o = append(o, 0xa9, 0x4d, 0x61, 0x78, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.MaxReason)
	// string "OrderID"
	o = append(o, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendInt32(o, z.OrderID)
	// string "TryBetCount"
	o = append(o, 0xab, 0x54, 0x72, 0x79, 0x42, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.TryBetCount)
	// string "OrderPrice"
	o = append(o, 0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x50, 0x72, 0x69, 0x63, 0x65)
	o = msgp.AppendFloat64(o, z.OrderPrice)
	// string "OrderStake"
	o = append(o, 0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x6b, 0x65)
	o = msgp.AppendFloat64(o, z.OrderStake)
	// string "OrderStatus"
	o = append(o, 0xab, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.OrderStatus)
	// string "CloseReason"
	o = append(o, 0xab, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.CloseReason)
	// string "PriceList"
	o = append(o, 0xa9, 0x50, 0x72, 0x69, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PriceList)))
	for za0001 := range z.PriceList {
		o, err = z.PriceList[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PriceList", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Side) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Index":
			z.Index, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "BetName":
			z.BetName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetName")
				return
			}
		case "Price":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "Xrate":
			z.Xrate, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Xrate")
				return
			}
		case "UserID":
			z.UserID, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "Bookie":
			z.Bookie, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bookie")
				return
			}
		case "CheckPrice":
			z.CheckPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckPrice")
				return
			}
		case "CheckMin":
			z.CheckMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckMin")
				return
			}
		case "CheckMax":
			z.CheckMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CheckMax")
				return
			}
		case "Offers":
			z.Offers, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offers")
				return
			}
		case "IsComplete":
			z.IsComplete, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsComplete")
				return
			}
		case "CreatedAt":
			z.CreatedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "LastData":
			z.LastData, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastData")
				return
			}
		case "Age":
			z.Age, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Age")
				return
			}
		case "BackupPrice":
			z.BackupPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BackupPrice")
				return
			}
		case "PriceCount":
			z.PriceCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceCount")
				return
			}
		case "BackupCount":
			z.BackupCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BackupCount")
				return
			}
		case "MinStake":
			z.MinStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinStake")
				return
			}
		case "MaxStake":
			z.MaxStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxStake")
				return
			}
		case "BetPrice":
			z.BetPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetPrice")
				return
			}
		case "BetStake":
			z.BetStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetStake")
				return
			}
		case "IsFirst":
			z.IsFirst, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsFirst")
				return
			}
		case "MinWin":
			z.MinWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinWin")
				return
			}
		case "MaxWin":
			z.MaxWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxWin")
				return
			}
		case "BetWin":
			z.BetWin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BetWin")
				return
			}
		case "FreeBalance":
			z.FreeBalance, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeBalance")
				return
			}
		case "FillFactor":
			z.FillFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FillFactor")
				return
			}
		case "EventFactor":
			z.EventFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventFactor")
				return
			}
		case "VoidFactor":
			z.VoidFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VoidFactor")
				return
			}
		case "StatsFactor":
			z.StatsFactor, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsFactor")
				return
			}
		case "ProfitMultiplier":
			z.ProfitMultiplier, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProfitMultiplier")
				return
			}
		case "WeightedPrice":
			z.WeightedPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedPrice")
				return
			}
		case "WeightedVolume":
			z.WeightedVolume, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedVolume")
				return
			}
		case "WeightedDistance":
			z.WeightedDistance, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeightedDistance")
				return
			}
		case "MinPercent":
			z.MinPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinPercent")
				return
			}
		case "MaxPercent":
			z.MaxPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPercent")
				return
			}
		case "MaxReason":
			z.MaxReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxReason")
				return
			}
		case "OrderID":
			z.OrderID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderID")
				return
			}
		case "TryBetCount":
			z.TryBetCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TryBetCount")
				return
			}
		case "OrderPrice":
			z.OrderPrice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderPrice")
				return
			}
		case "OrderStake":
			z.OrderStake, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderStake")
				return
			}
		case "OrderStatus":
			z.OrderStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderStatus")
				return
			}
		case "CloseReason":
			z.CloseReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CloseReason")
				return
			}
		case "PriceList":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PriceList")
				return
			}
			if cap(z.PriceList) >= int(zb0002) {
				z.PriceList = (z.PriceList)[:zb0002]
			} else {
				z.PriceList = make([]Price, zb0002)
			}
			for za0001 := range z.PriceList {
				bts, err = z.PriceList[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriceList", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Side) Msgsize() (s int) {
	s = 3 + 6 + msgp.Int16Size + 8 + msgp.StringPrefixSize + len(z.BetName) + 6 + msgp.Float64Size + 6 + msgp.Float64Size + 7 + msgp.Uint8Size + 7 + msgp.StringPrefixSize + len(z.Bookie) + 11 + msgp.Float64Size + 9 + msgp.Float64Size + 9 + msgp.Float64Size + 7 + msgp.Int16Size + 11 + msgp.BoolSize + 10 + msgp.TimeSize + 9 + msgp.TimeSize + 4 + msgp.Int16Size + 12 + msgp.Float64Size + 11 + msgp.Int16Size + 12 + msgp.Int16Size + 9 + msgp.Float64Size + 9 + msgp.Float64Size + 9 + msgp.Float64Size + 9 + msgp.Float64Size + 8 + msgp.BoolSize + 7 + msgp.Float64Size + 7 + msgp.Float64Size + 7 + msgp.Float64Size + 12 + msgp.Float64Size + 11 + msgp.Float64Size + 12 + msgp.Float64Size + 11 + msgp.Float64Size + 12 + msgp.Float64Size + 17 + msgp.Float64Size + 14 + msgp.Float64Size + 15 + msgp.Float64Size + 17 + msgp.Float64Size + 11 + msgp.Float64Size + 11 + msgp.Float64Size + 10 + msgp.StringPrefixSize + len(z.MaxReason) + 8 + msgp.Int32Size + 12 + msgp.Int16Size + 11 + msgp.Float64Size + 11 + msgp.Float64Size + 12 + msgp.StringPrefixSize + len(z.OrderStatus) + 12 + msgp.StringPrefixSize + len(z.CloseReason) + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.PriceList {
		s += z.PriceList[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SurebetDB) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Spread":
			z.Spread, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Spread")
				return
			}
		case "Key":
			z.Key, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "Volume":
			z.Volume, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
		case "IntervalCount":
			z.IntervalCount, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "IntervalCount")
				return
			}
		case "EventID":
			z.EventID, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "EventStarts":
			z.EventStarts, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "EventStarts")
				return
			}
		case "EventSport":
			z.EventSport, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EventSport")
				return
			}
		case "CalcProfit":
			z.CalcProfit, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcProfit")
				return
			}
		case "CalcGross":
			z.CalcGross, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcGross")
				return
			}
		case "CalcWinDiffPercent":
			z.CalcWinDiffPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CalcWinDiffPercent")
				return
			}
		case "CalcBeforeEvent":
			z.CalcBeforeEvent, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcBeforeEvent")
				return
			}
		case "CalcLastDataTs":
			z.CalcLastDataTs, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "CalcLastDataTs")
				return
			}
		case "CalcFirstIndex":
			z.CalcFirstIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstIndex")
				return
			}
		case "CalcSecondIndex":
			z.CalcSecondIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcSecondIndex")
				return
			}
		case "CalcLowerWinIndex":
			z.CalcLowerWinIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcLowerWinIndex")
				return
			}
		case "CalcHigherWinIndex":
			z.CalcHigherWinIndex, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcHigherWinIndex")
				return
			}
		case "CalcLeftBackupProfit":
			z.CalcLeftBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcLeftBackupProfit")
				return
			}
		case "CalcRightBackupProfit":
			z.CalcRightBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcRightBackupProfit")
				return
			}
		case "CalcBackupProfit":
			z.CalcBackupProfit, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "CalcBackupProfit")
				return
			}
		case "CalcFirstReason":
			z.CalcFirstReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstReason")
				return
			}
		case "StatsCountEvent":
			z.StatsCountEvent, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "StatsCountEvent")
				return
			}
		case "StatsCountLine":
			z.StatsCountLine, err = dc.ReadInt16()
			if err != nil {
				err = msgp.WrapError(err, "StatsCountLine")
				return
			}
		case "StatsAmountEvent":
			z.StatsAmountEvent, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountEvent")
				return
			}
		case "StatsAmountLine":
			z.StatsAmountLine, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountLine")
				return
			}
		case "Timing":
			err = z.Timing.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Timing")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if zb0002 != uint32(2) {
				err = msgp.ArrayError{Wanted: uint32(2), Got: zb0002}
				return
			}
			for za0001 := range z.Members {
				err = z.Members[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SurebetDB) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 27
	// write "ID"
	err = en.Append(0xde, 0x0, 0x1b, 0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "Spread"
	err = en.Append(0xa6, 0x53, 0x70, 0x72, 0x65, 0x61, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Spread)
	if err != nil {
		err = msgp.WrapError(err, "Spread")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "Volume"
	err = en.Append(0xa6, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.Volume)
	if err != nil {
		err = msgp.WrapError(err, "Volume")
		return
	}
	// write "IntervalCount"
	err = en.Append(0xad, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.IntervalCount)
	if err != nil {
		err = msgp.WrapError(err, "IntervalCount")
		return
	}
	// write "EventID"
	err = en.Append(0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.EventID)
	if err != nil {
		err = msgp.WrapError(err, "EventID")
		return
	}
	// write "EventStarts"
	err = en.Append(0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteTime(z.EventStarts)
	if err != nil {
		err = msgp.WrapError(err, "EventStarts")
		return
	}
	// write "EventSport"
	err = en.Append(0xaa, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.EventSport)
	if err != nil {
		err = msgp.WrapError(err, "EventSport")
		return
	}
	// write "CalcProfit"
	err = en.Append(0xaa, 0x43, 0x61, 0x6c, 0x63, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcProfit")
		return
	}
	// write "CalcGross"
	err = en.Append(0xa9, 0x43, 0x61, 0x6c, 0x63, 0x47, 0x72, 0x6f, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcGross)
	if err != nil {
		err = msgp.WrapError(err, "CalcGross")
		return
	}
	// write "CalcWinDiffPercent"
	err = en.Append(0xb2, 0x43, 0x61, 0x6c, 0x63, 0x57, 0x69, 0x6e, 0x44, 0x69, 0x66, 0x66, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CalcWinDiffPercent)
	if err != nil {
		err = msgp.WrapError(err, "CalcWinDiffPercent")
		return
	}
	// write "CalcBeforeEvent"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcBeforeEvent)
	if err != nil {
		err = msgp.WrapError(err, "CalcBeforeEvent")
		return
	}
	// write "CalcLastDataTs"
	err = en.Append(0xae, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x54, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.CalcLastDataTs)
	if err != nil {
		err = msgp.WrapError(err, "CalcLastDataTs")
		return
	}
	// write "CalcFirstIndex"
	err = en.Append(0xae, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcFirstIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcFirstIndex")
		return
	}
	// write "CalcSecondIndex"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcSecondIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcSecondIndex")
		return
	}
	// write "CalcLowerWinIndex"
	err = en.Append(0xb1, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x6f, 0x77, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcLowerWinIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcLowerWinIndex")
		return
	}
	// write "CalcHigherWinIndex"
	err = en.Append(0xb2, 0x43, 0x61, 0x6c, 0x63, 0x48, 0x69, 0x67, 0x68, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcHigherWinIndex)
	if err != nil {
		err = msgp.WrapError(err, "CalcHigherWinIndex")
		return
	}
	// write "CalcLeftBackupProfit"
	err = en.Append(0xb4, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x65, 0x66, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcLeftBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcLeftBackupProfit")
		return
	}
	// write "CalcRightBackupProfit"
	err = en.Append(0xb5, 0x43, 0x61, 0x6c, 0x63, 0x52, 0x69, 0x67, 0x68, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcRightBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcRightBackupProfit")
		return
	}
	// write "CalcBackupProfit"
	err = en.Append(0xb0, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.CalcBackupProfit)
	if err != nil {
		err = msgp.WrapError(err, "CalcBackupProfit")
		return
	}
	// write "CalcFirstReason"
	err = en.Append(0xaf, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.CalcFirstReason)
	if err != nil {
		err = msgp.WrapError(err, "CalcFirstReason")
		return
	}
	// write "StatsCountEvent"
	err = en.Append(0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.StatsCountEvent)
	if err != nil {
		err = msgp.WrapError(err, "StatsCountEvent")
		return
	}
	// write "StatsCountLine"
	err = en.Append(0xae, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt16(z.StatsCountLine)
	if err != nil {
		err = msgp.WrapError(err, "StatsCountLine")
		return
	}
	// write "StatsAmountEvent"
	err = en.Append(0xb0, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.StatsAmountEvent)
	if err != nil {
		err = msgp.WrapError(err, "StatsAmountEvent")
		return
	}
	// write "StatsAmountLine"
	err = en.Append(0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.StatsAmountLine)
	if err != nil {
		err = msgp.WrapError(err, "StatsAmountLine")
		return
	}
	// write "Timing"
	err = en.Append(0xa6, 0x54, 0x69, 0x6d, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = z.Timing.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Timing")
		return
	}
	// write "Members"
	err = en.Append(0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(2))
	if err != nil {
		err = msgp.WrapError(err, "Members")
		return
	}
	for za0001 := range z.Members {
		err = z.Members[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SurebetDB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 27
	// string "ID"
	o = append(o, 0xde, 0x0, 0x1b, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt64(o, z.ID)
	// string "Spread"
	o = append(o, 0xa6, 0x53, 0x70, 0x72, 0x65, 0x61, 0x64)
	o = msgp.AppendFloat64(o, z.Spread)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.Key)
	// string "Volume"
	o = append(o, 0xa6, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
	o = msgp.AppendInt16(o, z.Volume)
	// string "IntervalCount"
	o = append(o, 0xad, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.IntervalCount)
	// string "EventID"
	o = append(o, 0xa7, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44)
	o = msgp.AppendInt32(o, z.EventID)
	// string "EventStarts"
	o = append(o, 0xab, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendTime(o, z.EventStarts)
	// string "EventSport"
	o = append(o, 0xaa, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, z.EventSport)
	// string "CalcProfit"
	o = append(o, 0xaa, 0x43, 0x61, 0x6c, 0x63, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendFloat64(o, z.CalcProfit)
	// string "CalcGross"
	o = append(o, 0xa9, 0x43, 0x61, 0x6c, 0x63, 0x47, 0x72, 0x6f, 0x73, 0x73)
	o = msgp.AppendFloat64(o, z.CalcGross)
	// string "CalcWinDiffPercent"
	o = append(o, 0xb2, 0x43, 0x61, 0x6c, 0x63, 0x57, 0x69, 0x6e, 0x44, 0x69, 0x66, 0x66, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.CalcWinDiffPercent)
	// string "CalcBeforeEvent"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.CalcBeforeEvent)
	// string "CalcLastDataTs"
	o = append(o, 0xae, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x54, 0x73)
	o = msgp.AppendInt64(o, z.CalcLastDataTs)
	// string "CalcFirstIndex"
	o = append(o, 0xae, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcFirstIndex)
	// string "CalcSecondIndex"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcSecondIndex)
	// string "CalcLowerWinIndex"
	o = append(o, 0xb1, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x6f, 0x77, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcLowerWinIndex)
	// string "CalcHigherWinIndex"
	o = append(o, 0xb2, 0x43, 0x61, 0x6c, 0x63, 0x48, 0x69, 0x67, 0x68, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt16(o, z.CalcHigherWinIndex)
	// string "CalcLeftBackupProfit"
	o = append(o, 0xb4, 0x43, 0x61, 0x6c, 0x63, 0x4c, 0x65, 0x66, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcLeftBackupProfit)
	// string "CalcRightBackupProfit"
	o = append(o, 0xb5, 0x43, 0x61, 0x6c, 0x63, 0x52, 0x69, 0x67, 0x68, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcRightBackupProfit)
	// string "CalcBackupProfit"
	o = append(o, 0xb0, 0x43, 0x61, 0x6c, 0x63, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x74)
	o = msgp.AppendInt16(o, z.CalcBackupProfit)
	// string "CalcFirstReason"
	o = append(o, 0xaf, 0x43, 0x61, 0x6c, 0x63, 0x46, 0x69, 0x72, 0x73, 0x74, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.CalcFirstReason)
	// string "StatsCountEvent"
	o = append(o, 0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt16(o, z.StatsCountEvent)
	// string "StatsCountLine"
	o = append(o, 0xae, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendInt16(o, z.StatsCountLine)
	// string "StatsAmountEvent"
	o = append(o, 0xb0, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt32(o, z.StatsAmountEvent)
	// string "StatsAmountLine"
	o = append(o, 0xaf, 0x53, 0x74, 0x61, 0x74, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendInt32(o, z.StatsAmountLine)
	// string "Timing"
	o = append(o, 0xa6, 0x54, 0x69, 0x6d, 0x69, 0x6e, 0x67)
	o, err = z.Timing.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timing")
		return
	}
	// string "Members"
	o = append(o, 0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(2))
	for za0001 := range z.Members {
		o, err = z.Members[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SurebetDB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Spread":
			z.Spread, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spread")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "Volume":
			z.Volume, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
		case "IntervalCount":
			z.IntervalCount, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IntervalCount")
				return
			}
		case "EventID":
			z.EventID, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventID")
				return
			}
		case "EventStarts":
			z.EventStarts, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventStarts")
				return
			}
		case "EventSport":
			z.EventSport, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventSport")
				return
			}
		case "CalcProfit":
			z.CalcProfit, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcProfit")
				return
			}
		case "CalcGross":
			z.CalcGross, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcGross")
				return
			}
		case "CalcWinDiffPercent":
			z.CalcWinDiffPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcWinDiffPercent")
				return
			}
		case "CalcBeforeEvent":
			z.CalcBeforeEvent, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcBeforeEvent")
				return
			}
		case "CalcLastDataTs":
			z.CalcLastDataTs, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLastDataTs")
				return
			}
		case "CalcFirstIndex":
			z.CalcFirstIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstIndex")
				return
			}
		case "CalcSecondIndex":
			z.CalcSecondIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcSecondIndex")
				return
			}
		case "CalcLowerWinIndex":
			z.CalcLowerWinIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLowerWinIndex")
				return
			}
		case "CalcHigherWinIndex":
			z.CalcHigherWinIndex, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcHigherWinIndex")
				return
			}
		case "CalcLeftBackupProfit":
			z.CalcLeftBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcLeftBackupProfit")
				return
			}
		case "CalcRightBackupProfit":
			z.CalcRightBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcRightBackupProfit")
				return
			}
		case "CalcBackupProfit":
			z.CalcBackupProfit, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcBackupProfit")
				return
			}
		case "CalcFirstReason":
			z.CalcFirstReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CalcFirstReason")
				return
			}
		case "StatsCountEvent":
			z.StatsCountEvent, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsCountEvent")
				return
			}
		case "StatsCountLine":
			z.StatsCountLine, bts, err = msgp.ReadInt16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsCountLine")
				return
			}
		case "StatsAmountEvent":
			z.StatsAmountEvent, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountEvent")
				return
			}
		case "StatsAmountLine":
			z.StatsAmountLine, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsAmountLine")
				return
			}
		case "Timing":
			bts, err = z.Timing.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timing")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if zb0002 != uint32(2) {
				err = msgp.ArrayError{Wanted: uint32(2), Got: zb0002}
				return
			}
			for za0001 := range z.Members {
				bts, err = z.Members[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SurebetDB) Msgsize() (s int) {
	s = 3 + 3 + msgp.Int64Size + 7 + msgp.Float64Size + 4 + msgp.StringPrefixSize + len(z.Key) + 7 + msgp.Int16Size + 14 + msgp.Int16Size + 8 + msgp.Int32Size + 12 + msgp.TimeSize + 11 + msgp.StringPrefixSize + len(z.EventSport) + 11 + msgp.Float64Size + 10 + msgp.Float64Size + 19 + msgp.Float64Size + 16 + msgp.Int16Size + 15 + msgp.Int64Size + 15 + msgp.Int16Size + 16 + msgp.Int16Size + 18 + msgp.Int16Size + 19 + msgp.Int16Size + 21 + msgp.Int16Size + 22 + msgp.Int16Size + 17 + msgp.Int16Size + 16 + msgp.StringPrefixSize + len(z.CalcFirstReason) + 16 + msgp.Int16Size + 15 + msgp.Int16Size + 17 + msgp.Int32Size + 16 + msgp.Int32Size + 7 + z.Timing.Msgsize() + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Members {
		s += z.Members[za0001].Msgsize()
	}
	return
}
